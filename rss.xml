<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Mon, 13 Jan 2025 08:53:45 GMT</pubDate>
    <lastBuildDate>Mon, 13 Jan 2025 08:53:45 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>设计模式</category>
    <category>算法 二分搜索法</category>
    <category>JVM</category>
    <item>
      <title>观察者模式</title>
      <link>https://merryldt.github.io/moyu/design/03Publisth_Subscribe.html</link>
      <guid>https://merryldt.github.io/moyu/design/03Publisth_Subscribe.html</guid>
      <source url="https://merryldt.github.io/rss.xml">观察者模式</source>
      <description>观察者模式又叫发布订阅模式(Publisth/Subscribe)； 定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象关注一个主题对象，这个主题对象在发生变化时，会通知所有观察者对象，使他们能够自动的发生更新操作。 结构图</description>
      <category>设计模式</category>
      <pubDate>Mon, 13 Jan 2025 08:51:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>观察者模式又叫发布订阅模式(Publisth/Subscribe)；</p>
<h1> 定义</h1>
<p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象关注一个主题对象，这个主题对象在发生变化时，会通知所有观察者对象，使他们能够自动的发生更新操作。</p>
<figure><figcaption>结构图</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>优先队列</title>
      <link>https://merryldt.github.io/moyu/algorithm/basic/02_priority_queue.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/basic/02_priority_queue.html</guid>
      <source url="https://merryldt.github.io/rss.xml">优先队列</source>
      <description>优先队列 实现核心： 二叉堆 定义： 二叉堆（Binary Heap）性质比二叉搜索树 BST 还简单。其主要操作就两个，sin（下沉）和&amp;nbsp;swim（上浮），用以维护二叉堆的性质。 二叉堆在逻辑上是一种特殊的二叉树（完全二叉树），只不过存储在数组里。 图示： arr是一个字符数组，注意数组的第一个索引 0 空着不用。 把&amp;nbsp;arr[1]作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</description>
      <pubDate>Mon, 13 Jan 2025 08:51:31 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 优先队列</h1>
<h2> 实现核心： 二叉堆</h2>
<h3> 定义：</h3>
<p>二叉堆（Binary Heap）性质比二叉搜索树 BST 还简单。其主要操作就两个，<code>sin</code>（下沉）和&nbsp;<code>swim</code>（上浮），用以维护二叉堆的性质。</p>
<p>二叉堆在逻辑上是一种特殊的二叉树（完全二叉树），只不过存储在数组里。</p>
<p>图示：</p>
<p><code>arr</code>是一个字符数组，注意数组的第一个索引 0 空着不用。</p>
<p>把&nbsp;<code>arr[1]</code>作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p>
<figure><figcaption>Untitled</figcaption></figure>
<h3> 数组的方式，操作树的索引：</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 最大堆和最小堆：</h3>
<ul>
<li>最大堆的性质是：每个节点都大于等于它的两个子节点;</li>
<li>最小堆的性质是：每个节点都小于等于它的子节点。</li>
</ul>
<h2> <strong>实现 swim 和 sink</strong></h2>
<p>在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<h3> 最大堆的实现：</h3>
<p>对于最大堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<p><strong>上浮的代码实现：</strong></p>
<p>上浮某个节点 A，只需要 A 和其父节点比较大小即可。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下沉的代码实现：</strong></p>
<p>下沉某个节点 A，需要 A 和其<strong>两个子节点</strong>比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 最小堆的实现：</h3>
<p>对于最小堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<p><strong>上浮的代码实现：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下沉的代码实现：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 插入和删除操作：</h2>
<p>插入：</p>
<p><strong>先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除：</p>
<p><strong>先把堆顶元素&nbsp;<code>A</code>&nbsp;和堆底最后的元素&nbsp;<code>B</code>&nbsp;对调，然后删除&nbsp;<code>A</code>，最后让&nbsp;<code>B</code>&nbsp;下沉到正确位置</strong>。</p>
<p>如果是最大堆，删除并返回的就是最大元素；如果是最小堆，删除并返回的就是最小元素。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最大堆的完整实现：</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最小堆的完整实现：</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 优先队列：</h1>
]]></content:encoded>
    </item>
    <item>
      <title>二分搜索法</title>
      <link>https://merryldt.github.io/moyu/algorithm/basic/03_binarySearch.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/basic/03_binarySearch.html</guid>
      <source url="https://merryldt.github.io/rss.xml">二分搜索法</source>
      <description>三类: 基本的二分查找 寻找左侧边界的二分查找 寻找又侧边界的二分查找 基本的二分查找 复杂度分析: 递归： 时间复杂度: O(m+n), m 和n 分别为两个链表的长度.每次递归调用都会去掉一个链表的头节点，递归结束的条件是一个链表为空。递归函数只会调用每个节点一次。 因此，时间复杂度取决于合并后的链表长度。 即O(m+n) 空间复杂度: O(m+n), 递归调用函数需要栈空间,栈空间的大小取决于递归调用的深度。结束递归时函数对多调用 m +n 次，因此空间复杂度为 O(m+n) 非递归： 时间复杂度; O(m+n); 每次循环迭代，两个链表只会有一个元素都被放进合并链表中。因此，while循环的次数不会超过两个链表的长度之和。其他操作都是常数级别。 空间复杂度： O(1)； 只需常数空间存放若干变量。</description>
      <category>算法 二分搜索法</category>
      <pubDate>Mon, 13 Jan 2025 08:51:31 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 三类:</h2>
<h3> 基本的二分查找</h3>
<h3> 寻找左侧边界的二分查找</h3>
<h3> 寻找又侧边界的二分查找</h3>
<h3> 基本的二分查找</h3>

<p><strong>复杂度分析</strong>:</p>
<ul>
<li>递归：
<ul>
<li>时间复杂度: O(m+n), m 和n 分别为两个链表的长度.每次递归调用都会去掉一个链表的头节点，递归结束的条件是一个链表为空。递归函数只会调用每个节点一次。
因此，时间复杂度取决于合并后的链表长度。 即O(m+n)</li>
<li>空间复杂度: O(m+n), 递归调用函数需要栈空间,栈空间的大小取决于递归调用的深度。结束递归时函数对多调用 m +n 次，因此空间复杂度为 O(m+n)</li>
</ul>
</li>
<li>非递归：
<ul>
<li>时间复杂度; O(m+n); 每次循环迭代，两个链表只会有一个元素都被放进合并链表中。因此，while循环的次数不会超过两个链表的长度之和。其他操作都是常数级别。</li>
<li>空间复杂度： O(1)； 只需常数空间存放若干变量。</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>使用Arthas 诊断代码-接口耗时越来越长,影响了业务实现</title>
      <link>https://merryldt.github.io/moyu/jvm/011_PracticeTow.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/011_PracticeTow.html</guid>
      <source url="https://merryldt.github.io/rss.xml">使用Arthas 诊断代码-接口耗时越来越长,影响了业务实现</source>
      <description>问题: 随着时间的增长，接口越来越慢,从1s的响应延长到10s 以上 @PostMapping(path=&amp;quot;/saveAnswer&amp;quot;) public String saveAnswer(@RequestBody AnswerInputo answerInputo){ System.out.println(&amp;quot;start save&amp;quot;); answerService.check(answerInputo); answerService.saveRecord(answerInputo); answerService.createOrder(answerInputo); answerService.save(answerInputo); System.out.println(&amp;quot;end save&amp;quot;); return &amp;quot;SUCCESS&amp;quot;; }</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 问题: 随着时间的增长，接口越来越慢,从1s的响应延长到10s 以上</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最初的想法是：添加日志,重新发版本</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 这样的问题：</h3>
<ol>
<li>添加的无用日志太多；</li>
<li>容易漏,导致关键的位置没有分析到；</li>
<li>因为此类问题大部分都是生产发现,线上如果调试,就需要不断发布,影响用户使用；</li>
</ol>
<h2> 使用 Arthas</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据提示，选择对应的java应用。
</p>
<h3> trace 命令指定追踪的类和方法</h3>
<p>输入要追踪的类和方法。输入格式为：trace {全限定类名} {方法名}：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 定位耗时部分</h4>
<ol>
<li>访问下controller中的callServices这个方法。这个时候arthas控制台有如下输出：</li>
</ol>
<p>
定位到service;</p>
<ol start="2">
<li>trace 命令service的方法。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>
</p>
<p>一目了然，可以看到是getTeamNumByTeamId() 方法耗时占比37%以上。</p>
<h3> trace 结合OGNL表达式 命令指定追踪的类和方法</h3>
<p>OGNL表达式，支持各种复杂的嵌套结构及比较逻辑.</p>
<h4> 根据参数筛选： 入参第一个参数等于 dd</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 根据运行时间筛选：耗时大于800ms</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> arthas 采集火焰图</h2>
<h3> 开始采集</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 查看采集的样本数量</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 停止采样</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><figcaption>Alt text</figcaption></figure>
<h3> 结果</h3>
<figure><figcaption>Alt text</figcaption></figure>
<p>【<strong>纵轴(Y轴)</strong>】表示的是方法调用的调用栈信息，即从最外层方法到最内层方法的调用信息。</p>
<p>【<strong>横轴(X轴)</strong>】表示的是方法调用的持续时间，即方法在执行过程中所占用的时间长度。</p>
<p>在一个火焰图中，越靠近下面的函数在x轴上越长是正常的，而越往上的函数就应该越短。所以，火焰图也像是一个个山峰。那么，如果火焰图出现较宽的峰顶，那就往往是性能瓶颈。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Arthas 入门</title>
      <link>https://merryldt.github.io/moyu/jvm/08001_ArthasOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/08001_ArthasOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Arthas 入门</source>
      <description>Arthas 全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 【开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。】 快速使用 arthas 执行arahas程序的用户需要和目标进程(即java应用)具有相同的权限 最好采用同一个用户执行： sudu su root</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Arthas</h2>
<p>全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p>
<p>【<strong>开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。</strong>】</p>
<h2> 快速使用 arthas</h2>
<p><strong>执行arahas程序的用户需要和目标进程(即java应用)具有相同的权限</strong>
最好采用同一个用户执行： sudu su root</p>
<h3> 例子</h3>
<ol>
<li>java 应用程序： math-game.jar</li>
<li>arthas 应用 arthas-boot.jar</li>
</ol>
<h3> 切换用户： sudo su root</h3>
<h3> 下载和启动java 应用程序</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 下载和启动arthas</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 选择java进程：</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>math-game进程是第 2 个，则输入 2，再输入回车/enter。Arthas 会 attach 到目标进程上，并输出日志</p>
<h4> 显示如下表示成功：</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： dashboard</h2>
<ul>
<li>功能 展示当前java进程的实时数据（线程、gc、jvm内存占用等）信息</li>
</ul>
<p>命令指导：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入dashboard，按回车/enter，会展示当前进程的信息，按ctrl+c可以中断执行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： thread</h2>
<ul>
<li>展示当前java进程详细的线程信息
目前java 部分程序使用的都是springboot,此类程序ID =1，通常是main函数</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>命令使用示例</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： jad</h2>
<p>反编译类： demo.Mathgame</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> watch</h2>
<ul>
<li>观测某方法执行的详情
通过watch命令来查看demo.MathGame#primeFactors函数的返回值：</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> monitor</h2>
<ul>
<li>
<p>统计方法一段周期内的执行情况</p>
</li>
<li>
<p>命令</p>
</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 退出 arthas</h2>
<ul>
<li>
<p>quit 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</p>
</li>
<li>
<p>exit 等同于quit</p>
</li>
<li>
<p>stop 关闭 Arthas 服务端，所有 Arthas 客户端全部退出</p>
</li>
</ul>
<p>如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p>
<p>如果想完全退出 arthas，可以执行stop命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Arthas 实战使用</title>
      <link>https://merryldt.github.io/moyu/jvm/08002_ArthasTwo.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/08002_ArthasTwo.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Arthas 实战使用</source>
      <description>修改日志级别 修改指定类的日志级别 修改全局日志级别 # 查找到具体的类信息 sc -d *VipUserController # 使用ognl表达式查看日志属性的信息,判断日志级别 ognl -c classLoaderHash &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger&amp;quot; # 使用ognl表达式修改日志级别 ognl -c classLoaderHash &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&amp;quot; # 再次查看日志级别，判断是否修改成功 ognl &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger&amp;quot; # 修改全局日志级别 ognl -c classLoaderHash &amp;apos;@org.slf4j.LoggerFactory@getLogger(&amp;quot;root&amp;quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&amp;apos;</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 修改日志级别</h2>
<ul>
<li>修改指定类的日志级别</li>
<li>修改全局日志级别</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 更新代码、热加载</h2>
<ul>
<li>线上代码出现问题,想不重启,修改几行后，实现热加载。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编辑源码,修改后：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试,访问接口，查看结果</p>
<h2> 排查函数调用异常</h2>
<ul>
<li>观测方法执行异常具体信息，入参、出参等</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> arthas 后台异步执行诊断任务</h2>
<ul>
<li>执行dashboard、watch、trace等命令时，可将命令执行挂起，将结果输出到文件中，供后续分析，不影响其他命令执行。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 排查方法执行效率问题</h2>
<ul>
<li>线上某个接口执行慢，无法确定是哪一段代码的问题。可根据各方法执行耗时，缩小排查范围。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Kubernetes 组件</title>
      <link>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes 组件</source>
      <description>Kubernetes 组件 前提 部署完 Kubernetes，便拥有了一个完整的集群。 一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。 工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。 image.png 控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes 组件</h1>
<h2> 前提</h2>
<p>部署完 Kubernetes，便拥有了一个完整的集群。</p>
<p>一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。
工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。
在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。</p>
<p>image.png</p>
<h2> 控制平面组件（Control Plane Components）</h2>
<p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。
然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p>
<h3> kube-apiserver</h3>
<p>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<h3> etcd</h3>
<p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。</p>
<h3> kube-scheduler</h3>
<p>kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h3> kube-controller-manager</h3>
<p>kube-controller-manager 是控制平面的组件， 负责<strong>运行控制器进程</strong>。
从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。
例如:</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
<h3> cloud-controller-manager</h3>
<p>cloud-controller-manager 仅运行特定于云平台的控制器。
一个 Kubernetes 控制平面组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<h2> Node 组件</h2>
<p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h3> kubelet</h3>
<p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。
kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h3> kube-proxy</h3>
<p>kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。
kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。
如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<h3> Container Runtime</h3>
<p>容器运行环境是负责运行容器的软件。
Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。</p>
<h2> 插件(Addons)</h2>
<p>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p>
<h3> DNS</h3>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。
几乎所有 Kubernetes 集群都应该有集群 DNS。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>