<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Sat, 22 Jul 2023 09:16:50 GMT</pubDate>
    <lastBuildDate>Sat, 22 Jul 2023 09:16:50 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>JVM</category>
    <item>
      <title>纯Java自带工具排查JVM</title>
      <link>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">纯Java自带工具排查JVM</source>
      <description>1. 获取java 进程的pid ps -ef | grep java jps 2. 使用jmap jmap -heap pid 获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。 root@iZuf64eg43tiam73abxiweZ:~# /usr/local/btjdk/jdk8/bin/jmap -heap 1028098 Attaching to process ID 1028098, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.71-b00 #1. using parallel threads in the new generation. using thread-local object allocation. Concurrent Mark-Sweep GC # 2. Heap Configuration: MinHeapFreeRatio = 40 MaxHeapFreeRatio = 70 MaxHeapSize = 4294967296 (4096.0MB) NewSize = 348913664 (332.75MB) MaxNewSize = 348913664 (332.75MB) OldSize = 3946053632 (3763.25MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB) #3. Heap Usage: New Generation (Eden + 1 Survivor Space): capacity = 314048512 (299.5MB) used = 166875944 (159.14530181884766MB) free = 147172568 (140.35469818115234MB) 53.136995598947465% used Eden Space: capacity = 279183360 (266.25MB) used = 132010792 (125.89530181884766MB) free = 147172568 (140.35469818115234MB) 47.28462040144513% used From Space: capacity = 34865152 (33.25MB) used = 34865152 (33.25MB) free = 0 (0.0MB) 100.0% used To Space: capacity = 34865152 (33.25MB) used = 0 (0.0MB) free = 34865152 (33.25MB) 0.0% used concurrent mark-sweep generation: capacity = 3946053632 (3763.25MB) used = 1832479232 (1747.58837890625MB) free = 2113574400 (2015.66162109375MB) 46.43827486630572% used 38355 interned Strings occupying 4029456 bytes.</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1. 获取java 进程的pid</h1>
<ol>
<li>ps -ef | grep java
</li>
<li>jps
</li>
</ol>
<h1> 2. 使用jmap</h1>
<h2> jmap -heap pid</h2>
<p>获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>第一部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用的是serial收集器（也叫串行收集器）即 Mark Sweep Compact GC。</li>
</ul>
<ol start="2">
<li>第二部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>MinHeapFreeRatio和MaxHeapFreeRatio: 设置堆的最小最大空闲比例。</li>
<li>MaxHeapSize: 堆的最大大小。</li>
<li>NewSize: 新生代的默认值。</li>
<li>MaxNewSize: 新生代的最大值</li>
<li>OldSize: 老年代的默认值。</li>
<li>NewRatio: 新生代和老年代的大小比例，即老年代:新生代=2:1,默认为2.</li>
<li>SurvivorRatio: 新生代中的eden区与survivor的比例=8:1.</li>
<li>MetaspaceSize: 1.8 开始叫元空间大小,使用本地内存的</li>
<li>CompressedClassSpaceSize: 类指针压缩空间大小, 默认为1G</li>
<li>MaxMetaspaceSize: 元空间的最大值。一般设置和MetaspaceSize一样大小。</li>
<li>G1HeapRegionSize: G1区块的大小, 取值为1M至32M. 其取值是要根据最小Heap大小划分出2048个区块</li>
</ul>
<ol start="3">
<li>第三部分:</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>新生代: 指eden加上一个survivor空间。容量有300M这样，使用了159M，还有140M空闲. 接近53%的使用率。（根据分代的思想，新生代都是一个eden 加上2个survivor）</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>单独的eden区: 大小为266M,使用125M,空闲140, 使用率47%</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>一个surivor区，是在使用着的</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另一个survivor的使用情况。此时没有被使用。和From Space 大小一致；</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>老年代： 总的大小是3763M，使用1747M,空闲2015M,使用率是46%。</li>
</ul>
<ol start="4">
<li>总结：
为java 进程分配了 4096M 的内存；
Eden Space + From Space + To Space + concurrent mark-sweep generation = 4096</li>
</ol>
<h1> 3. 使用jstat</h1>
<p>jstat -gc -t 1028098  60000 20</p>
<p>
从图中红框标记的的两条数据分析：</p>
<ul>
<li>一分钟采集1次gc 的数据，第一条和最后一条就是 19分钟。</li>
</ul>
<ol>
<li>GCT 总的gc 时间是 891.076秒</li>
<li>GCT 总的gc 时间是  895.115 秒
系统的吞吐量 = 1- （895.115-891.076）/ 19 *60   = 1- 0.0035  = 0.9965 = 99.65%</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Jvm的内存结构和对象分配</title>
      <link>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Jvm的内存结构和对象分配</source>
      <description>图示 内存区域划分 JVM 内存区域 内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。 JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。 不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 线程 每个JVM只有一个Runtime实例。称为运行时环境。 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。） 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 图示</h1>
<figure><figcaption>内存区域划分</figcaption></figure>
<h1> JVM 内存区域</h1>
<ol>
<li>内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。</li>
<li>JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。</li>
<li>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li>
</ol>
<h2> 线程</h2>
<ol>
<li>每个JVM只有一个Runtime实例。称为运行时环境。</li>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li>
<li>在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。）</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li>
</ol>
<h3> 守护线程、普通线程</h3>
<h2> 一、程序计算器</h2>
<p>极小的内存空间,线程私有的,当前线程的行号指示器，程序的分支、循环、跳转、异常处理、线程恢复等基本功能都需要依赖程序计算器；比如(多线程切换)。<br>
线程执行的是:</p>
<ol>
<li>Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>Native方法，计数器值为空；</li>
</ol>
<p>值得注意的是它是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域</p>
<h2> 二、java虚拟机栈</h2>
<ol>
<li>
<p>虚拟机栈描述的是java方法执行的内存模型：线程私有的，生命周期与线程相同。</p>
</li>
<li>
<p>每个方法在执行的同时都会创建一个栈帧用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息；方法的调用直至执行完成的过程，对应着栈帧在虚拟机栈中<strong>入栈到出栈</strong>的过程。</p>
</li>
<li>
<p>虚拟机栈主要的部分是<strong>局部变量表</strong> ，其存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址);</p>
</li>
<li>
<p><u>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小</u>。</p>
</li>
<li>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出<strong>OutOfMemoryErro</strong>异常。</p>
</li>
</ol>
<h2> 三、本地方法栈</h2>
<p>与虚拟机栈作用类似，本地方法栈是虚拟机栈使用到的Native方法服务；SunHotSpot虚拟机把本地方法栈和虚拟机栈结合; 本地方法栈也会报虚拟机栈的两种异常。</p>
<h2> 四、java堆</h2>
<ol>
<li>
<p>java虚拟机管理的最大的一块内存；</p>
</li>
<li>
<p>所有线程共享的内存区域；</p>
</li>
<li>
<p>目的：存放对象实例，几乎所有的对象实例都在这里分配内存；（所有的对象实例以及数组都要在堆上分配）特别注意的是： 随着JIT编译器的发展与逃逸分析技术的成熟，<strong>栈上分配、标量替换优化技术</strong>带来了变化。不是所有对象都在堆上分配内存了。</p>
</li>
<li>
<p>java虚拟机规范规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可；实现时，即可是固定大小的，也可是可扩展的；当前主流的虚拟机都是可扩展的，通过-Xmx和-Xms控制； 如果堆中没有内存，并且堆也无法扩展 ，抛出OutOfMemoryError异常。</p>
</li>
<li>
<p>java堆是垃圾收集的主要区域，也称为“GC堆”;</p>
<ul>
<li>从内存回收的角度：基本采用分代收集算法，java堆分为新生代(Eden空间、From Survivor空间、To Survivor空间)和老年代；</li>
<li>从内存分配的角度：线程共享的java堆中可能划分出多个线程私有的分配缓冲区。目的是为了更好地、更快地回收内存。</li>
</ul>
</li>
</ol>
<h2> 五、方法区</h2>
<ol>
<li>存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li>所有线程共享的内存区域。</li>
<li>在HostSpot虚拟机中，使用永久代来实现方法区，这样的话垃圾收集器可以像管理Java堆一样管理这部分内存； Jdk1.7中，永久代中的字符串常量池移出。 为Native Memory实现方法区做准备。1.8称为元空间，默认的大小为MetaspaceSize 值21M.</li>
<li>方法区和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集；垃圾收集行为在方法区较少出现，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载；（回收效果差，类型卸载要求高）回收非常有必要，当方法区无法满足内存分配需求时，将抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h2> 六、运行时常量池</h2>
<ol>
<li>方法区的一部分;</li>
<li>存放的是类加载后<strong>class文件中常量池的信息</strong>;Class文件包括： 1 常量池(用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中) 2 类的基本描述信息（字段、方法、接口）</li>
</ol>
<p>运行时常量池，细节要求不高，可以根据不同的需求来实现该内存区域； Class包括其中的常量池，格式要求严格，具体到每一个字节存储的数据都必须符合才能被虚拟机认可、装载和执行；运行时常量池，不仅保存Class文件中描述的符号引用，而且也保存翻译的直接引用。</p>
<p>java语言的动态性，意味着并不要求常量一定只有编译器才能产生，也就是说不是只有提前放置在Class文件常量池中的内容才能进入方法区的运行时常量池； 在运行期也可以将新的常量放入运行时常量池，比如String的intern（）方法(调用该方法，如果常量池中包含了一个和当前对象相等的字符串则返回常量池中的字符串， 否则把改字符串放到常量池中，并返回字符串的引用.)；常量池可能报<strong>OutOfMemoryError</strong>异常。</p>
<p>常量池在运行时加载到内存中后,称为运行时常量池。</p>
<h2> 七、直接内存</h2>
<ol>
<li>NIO类，一种基于通道与缓存区的I/o方式，可以使用Native函数库直接分配堆外内存，通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用；</li>
<li>NIO的使用在某些场合避免了在java堆和Native堆中来回复制数据，提高了性能；</li>
<li>直接内存不受java堆大小的控制，但是受到本机总内存大小以及处理器寻址空间的限制；</li>
<li>也是会报<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h1> 知识补充：</h1>
<h2> 逃逸分析</h2>
<p>目的就是减少内存堆分配压力；</p>
<p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它有可能被外部方法所引用，例如，作为调用参数传递到其他地方中，称为方法逃逸。</p>
<h3> 基于逃逸分析，可以进行 同步消除、栈上分配以及标量替换的优化。</h3>
<h3> 例子：</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部
。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以做一些修改：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逃逸分析包括：</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 同步消除(锁消除)</h2>
<ol>
<li>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
</li>
<li>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
</li>
<li>
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</li>
<li>
<p>虚拟机会根据自己的代码检测结果取消一些加锁逻辑。</p>
</li>
<li>
<p>虚拟机通过检测会发现一些代码中不可能出现数据竞争，但是代码中又有加锁逻辑，为了提高性能，就消除这些锁。</p>
</li>
</ol>
<p>如果一段代码中，在堆上的所有数据都不会被其他线程访问到，那就可以把它们当成线程私有数据，自然就不需要同步加锁了。</p>
<h3> 经典例子：</h3>
<p>String 字符串拼接：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开编译后的字节码我们可以发现加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b”等效于下面的代码片。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>append方法时一个同步方法，它的方法签名是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时候，编译器就会判断出sb这个对象并不会被这段代码块以外的地方访问到，更不会被其他线程访问到，这时候的加锁就是完全没必要的，编译器就会把这里的加锁代码消除掉，
体现到java源码上就是把append方法的synchronized修饰符给去掉了。</p>
<h2> 栈上分配</h2>
<ol>
<li>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</li>
<li>栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</li>
<li>如果逃逸分析能够证明某些新建的 <strong>对象不逃逸</strong> ，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。</li>
</ol>
<h2> 标量替换</h2>
<p>定义：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<p>以上代码，经过标量替换后，就会变成：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p>标量替换为栈上分配提供了很好的基础。</p>
<p>由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。</p>
]]></content:encoded>
    </item>
    <item>
      <title>类的加载</title>
      <link>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory1ClassReload.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory1ClassReload.html</guid>
      <source url="https://merryldt.github.io/rss.xml">类的加载</source>
      <description>类的生命周期 Alt text 过程 加载（load） 通过一个类的全限定名来获取定义此类的二进制字节流; 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构; 链接(Linking) 校验 目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 类的生命周期</h1>
<figure><figcaption>Alt text</figcaption></figure>
<h1> 过程</h1>
<h2> 加载（load）</h2>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流;</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;</li>
</ol>
<h2> 链接(Linking)</h2>
<h3> 校验</h3>
<p>目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>
主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h3> 准备</h3>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用final 修饰的static，因为final 在编译的时候就会分配了,准备阶段会显示初始化；</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到JAVA堆中.</li>
</ul>
<h3> 解析</h3>
<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM 在执行完初始化之后再执行; 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>各虚拟机能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li>
<li>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_inf等。</li>
<li>对同一个符号引用进行多次解析是可能的，所以虚拟机会被第一次解析的结果进行缓存，避免解析动作重复进行。</li>
</ul>
<h2> 初始化</h2>
<ol>
<li>真正开始执行类中定义的Java程序代码(或者说是字节码)；</li>
<li>根据程序员通过程序制定的主观计划去初始化类变量和其他资源。换个角度来说，初始化阶段是执行类构造器clinit方法的过程。clinit方法不需要定义，是Javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。构造器方法中指令按语句在源文件中出现的顺序执行。clinit不同于类的构造器。(关联: 构造器是虚拟机视角下的init)</li>
<li>若该类具有父类，JVM会保证子类的clinit执行钱，父类的clinit已经执行完毕。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>GC 体系总结</title>
      <link>https://merryldt.github.io/moyu/jvm/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">GC 体系总结</source>
      <description>背景 基础知识介绍 Mutator 应用程序,即垃圾生产者； Tlab Thread Local Allocation Buffer 的缩写，基于CAS 的独享线程(Mutator Threads) 可以优先将对象分配在Eden 中的一块内存，因为是Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个TLAB 都是一个线程独享的。 Card Table 卡表,主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为dirty,卡表的本质是用来解决跨代引用的问题。 解决的原理 Sla Service-Level Agreement(服务等级协议)的缩写；指的是系统服务提供者（Provider）对客户(Customer)的⼀个服务承诺。这是衡量⼀个⼤型分布式系统是否“健康”的常见⽅法。 可⽤性、准确性、系统容量和延迟 sla详解</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 背景</h1>
<h1> 基础知识介绍</h1>
<ol>
<li>
<p>Mutator<br>
应用程序,即垃圾生产者；</p>
</li>
<li>
<p>Tlab<br>
Thread Local Allocation Buffer 的缩写，基于CAS 的独享线程(Mutator Threads) 可以优先将对象分配在Eden 中的一块内存，因为是Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个TLAB 都是一个线程独享的。</p>
</li>
<li>
<p>Card Table<br>
卡表,主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为dirty,卡表的本质是用来解决跨代引用的问题。<br>
<a href="https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-works" target="_blank" rel="noopener noreferrer">解决的原理</a></p>
</li>
<li>
<p>Sla<br>
Service-Level Agreement(服务等级协议)的缩写；指的是系统服务提供者（Provider）对客户(Customer)的⼀个服务承诺。这是衡量⼀个⼤型分布式系统是否“健康”的常见⽅法。<br>
可⽤性、准确性、系统容量和延迟<br>
<a href="/moyu/jvm/09999_SLA.html" target="blank">sla详解</a></p>
</li>
</ol>
<h1> 路径</h1>
<figure><figcaption>Alt text</figcaption></figure>
<h2> 1. 建立知识体系</h2>
<blockquote>
<p>学习GC 的基础知识,包括:</p>
</blockquote>
<ol>
<li><a href="/moyu/jvm/02_jvm_Memory0Structure.html" target="blank">Jvm的内存结构和对象分配</a></li>
<li><a href="/moyu/jvm/03_GarbageCollectionMethod.html" target="blank">垃圾收集方法</a></li>
<li><a href="/moyu/jvm/04_GarbageCollector.html" target="blank">垃圾收集器</a></li>
<li><a href="/moyu/jvm/05_GCAnalysisTools.html" target="blank">掌握一些常用的GC问题分析工具</a></li>
</ol>
<h2> 2. 确定评价指标</h2>
<ol>
<li><a href="/moyu/jvm/06_GCEvaluationCriteria.html" target="blank">了解基本 GC 的评价方法</a></li>
<li>摸清如何设定独立系统的指标;</li>
<li>在业务场景中判断 GC 是否存在问题的手段;</li>
</ol>
<h2> 3. 场景调优实践</h2>
<ol>
<li><a href="/moyu/jvm/09_9CMS.html" target="blank">分析与解决九种 CMS 中常见 GC 问题场景</a></li>
<li><a href="/moyu/jvm/010_PracticeOne.html" target="blank">纯Java自带工具排查JVM</a></li>
</ol>
<h2> 4. 总结优化经验</h2>
]]></content:encoded>
    </item>
    <item>
      <title>垃圾收集方法</title>
      <link>https://merryldt.github.io/moyu/jvm/03_GarbageCollectionMethod.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/03_GarbageCollectionMethod.html</guid>
      <source url="https://merryldt.github.io/rss.xml">垃圾收集方法</source>
      <description>复制 整理 整理清楚</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> </h1>
<ol>
<li>复制</li>
<li>整理</li>
<li>整理清楚</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>垃圾收集器</title>
      <link>https://merryldt.github.io/moyu/jvm/04_GarbageCollector.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/04_GarbageCollector.html</guid>
      <source url="https://merryldt.github.io/rss.xml">垃圾收集器</source>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
    </item>
    <item>
      <title>常用的GC问题分析工具</title>
      <link>https://merryldt.github.io/moyu/jvm/05_GCAnalysisTools.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/05_GCAnalysisTools.html</guid>
      <source url="https://merryldt.github.io/rss.xml">常用的GC问题分析工具</source>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
    </item>
    <item>
      <title>基本 GC 的评价方法</title>
      <link>https://merryldt.github.io/moyu/jvm/06_GCEvaluationCriteria.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/06_GCEvaluationCriteria.html</guid>
      <source url="https://merryldt.github.io/rss.xml">基本 GC 的评价方法</source>
      <description>GC的两个核心指标 延迟(Latency): 最大停顿时间，即垃圾收集过程中一次STW的最长时间，越短越好，一定程度上可以接受频次的增大. 吞吐量(Throughput): 应用系统的生命周期内，由于GC线程会占用应用程序当前可用的CPU 时钟周期，吞吐量即为应用程序有效花费的时间占系统总运行时间的百分比。 例如： 系统运行了100min,GC耗时1min,则系统吞吐量为99%,吞吐量优先的收集器可以接受较长的停顿。 TP9999 图示 p99 即为一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%。</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> GC的两个核心指标</h1>
<h2> 延迟(Latency):</h2>
<p>最大停顿时间，即垃圾收集过程中一次STW的最长时间，越短越好，一定程度上可以接受频次的增大.</p>
<h3> 吞吐量(Throughput):</h3>
<p>应用系统的生命周期内，由于GC线程会占用应用程序当前可用的CPU 时钟周期，吞吐量即为应用程序有效花费的时间占系统总运行时间的百分比。<br>
例如： 系统运行了100min,GC耗时1min,则系统吞吐量为99%,吞吐量优先的收集器可以接受较长的停顿。</p>
<h1> TP9999 图示</h1>
<p>
p99 即为<strong>一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%</strong>。</p>
<h2> 例子：</h2>
<p>假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。<br>
1/10000 = (1(次数)* x (平均GC停顿时间)) /  y(总时间)<br>
5min 等于 5<em>60</em>1000 = 300000毫秒；30 /300000= 1/10000</p>
<h1> 读懂 GC Cause</h1>
<p>分析 GC 的问题，先要读懂 GC Cause，即 JVM 什么样的条件下选择进行 GC 操作<br>
重点需要关注的几个GC Cause：</p>
<h2> System.gc()：</h2>
<p>手动触发GC操作。</p>
<h2> CMS：</h2>
<p>CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</p>
<h2> Promotion Failure：</h2>
<p>Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。</p>
<h2> Concurrent Mode Failure：</h2>
<p>CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。</p>
<h2> GCLocker Initiated GC：</h2>
<p>如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
<h1> 判断是不是 GC 引发的问题？</h1>
<p>在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题？</p>
<h2> GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高等四个表象，如何判断哪个是根因？</h2>
<ul>
<li>
<p><strong>时序分析</strong>： 先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间 Gap），那么整个问题影响链就可能是：CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程Block增多 -&gt; RT 上涨。</p>
</li>
<li>
<p><strong>概率分析</strong>： 使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨。</p>
</li>
<li>
<p><strong>实验分析</strong>： 通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨。</p>
</li>
<li>
<p><strong>反证分析</strong>： 对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨。</p>
</li>
</ul>
<h2> 相应的问题，如何观察？</h2>
<h3> CPU 负载高：</h3>
<p>需要用火焰图看下热点</p>
<h3> 慢查询增多</h3>
<p>看下 DB 情况</p>
<h3> 线程 Block 引起</h3>
<p>看下锁竞争的情况</p>
<h1> GC 问题分类</h1>
<ul>
<li><strong>Unexpected GC</strong>： 意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。</li>
</ul>
<p>Space Shock： 空间震荡问题，参见“场景一：动态扩容引起的空间震荡”。
Explicit GC： 显示执行 GC 问题，参见“场景二：显式 GC 的去与留”。</p>
<ul>
<li>
<p><strong>Partial GC</strong>： 部分收集操作的 GC，只对某些分代/分区进行回收。</p>
<ol>
<li>
<p>Young GC： 分代收集里面的 Young 区收集动作，也可以叫做 Minor GC。</p>
<ul>
<li>ParNew： Young GC 频繁，参见“场景四：过早晋升”。</li>
</ul>
</li>
<li>
<p>Old GC： 分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。</p>
<ol>
<li>CMS： Old GC 频繁，参见“场景五：CMS Old GC 频繁”。</li>
<li>CMS： Old GC 不频繁但单次耗时大，参见“场景六：单次 CMS Old GC 耗时长”。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>Full GC</strong>： 全量收集的 GC，对整个堆进行回收，STW 时间会比较长，一旦发生，影响较大，也可以叫做 Major GC，参见“场景七：内存碎片&amp;收集器退化”。</p>
</li>
<li>
<p><strong>MetaSpace</strong> ： 元空间回收引发问题，参见“场景三：MetaSpace 区 OOM”。</p>
</li>
<li>
<p><strong>Direct Memory</strong>： 直接内存（也可以称作为堆外内存）回收引发问题，参见“场景八：堆外内存 OOM”。</p>
</li>
<li>
<p><strong>JNI</strong>： 本地 Native 方法引发问题，参见“场景九：JNI 引发的 GC 问题”。</p>
</li>
</ul>
<h1> 引入</h1>
<p><a href="/moyu/jvm/09002_ServerPerformanceParameters.html" target="blank">服务器的性能参数</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>SLA</title>
      <link>https://merryldt.github.io/moyu/jvm/09001_SLA.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/09001_SLA.html</guid>
      <source url="https://merryldt.github.io/rss.xml">SLA</source>
      <description>1. 可⽤性（Ava ila bilty） 可⽤性指的是系统服务能正常运⾏所占的时间百分⽐。 如果我们搭建了⼀个拥有“100％可⽤性”的系统服务，那就意味着这个系统在任何时候都能正常运⾏。是不是很完美？但真要实现这样的⽬标其实⾮常困难，并且成本也会很⾼。 我们知道，即便是⼤名⿍⿍的亚马逊AWS云计算服务这样⼤型的、对⽤户来说极为关键的系统，也不能承诺100％的可⽤性，它的系统服务从推出到现在，也有过服务中断（Service Outage）的时候。 对于许多系统⽽⾔，四个9的可⽤性（99.99％ Availability，或每年约50分钟的系统中断时间）即可以被认为是⾼可⽤性（High availability）。 说到这⾥，我来为你揭开⼀开始所提到的“99.9% Availability”的真实含义。 “99.9% Availability”指的是⼀天当中系统服务将会有⼤约86秒的服务间断期。服务间断也许是因为系统维护，也有可能是因为系统在更新升级系统服务。 86秒这个数字是怎么算出来的呢？ 99.9%意味着有0.1%的可能性系统服务会被中断，⽽⼀天中有24⼩时 × 60分钟 × 60秒，也就是有(24 × 60 × 60 × 0.001) = 86.4秒的可能系统服务被中断了。⽽上⾯所说的四个9的⾼可⽤性服务就是承诺可以将⼀天当中的服务中断时间缩短到只有(24 × 60 × 60 × 0.0001) = 8.64秒。</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1. 可⽤性（Ava ila bilty）</h1>
<p>可⽤性指的是系统服务能正常运⾏所占的时间百分⽐。
如果我们搭建了⼀个拥有“100％可⽤性”的系统服务，那就意味着这个系统在任何时候都能正常运⾏。是不是很完美？但真要实现这样的⽬标其实⾮常困难，并且成本也会很⾼。
我们知道，即便是⼤名⿍⿍的亚马逊AWS云计算服务这样⼤型的、对⽤户来说极为关键的系统，也不能承诺100％的可⽤性，它的系统服务从推出到现在，也有过服务中断（Service Outage）的时候。
对于许多系统⽽⾔，四个9的可⽤性（99.99％ Availability，或每年约50分钟的系统中断时间）即可以被认为是⾼可⽤性（High availability）。
说到这⾥，我来为你揭开⼀开始所提到的“99.9% Availability”的真实含义。
“99.9% Availability”指的是⼀天当中系统服务将会有⼤约86秒的服务间断期。服务间断也许是因为系统维护，也有可能是因为系统在更新升级系统服务。
86秒这个数字是怎么算出来的呢？
99.9%意味着有0.1%的可能性系统服务会被中断，⽽⼀天中有24⼩时 × 60分钟 × 60秒，也就是有(24 × 60 × 60 × 0.001) = 86.4秒的可能系统服务被中断了。⽽上⾯所说的四个9的⾼可⽤性服务就是承诺可以将⼀天当中的服务中断时间缩短到只有(24 × 60 × 60 × 0.0001) = 8.64秒。</p>
<h1> 2. 准确性（Ac c ur a c y）</h1>
<p>准确性指的是我们所设计的系统服务中，是否允许某些数据是不准确的或者是丢失了的。如果允许这样的情况发⽣，⽤户可以接受的概率（百分⽐）是多少？
这该怎么衡量呢？不同的系统平台可能会⽤不同的指标去定义准确性。很多时候，系统架构会以错误率（Error Rate）来定义这⼀项SLA。
怎么计算错误率呢？可以⽤导致系统产⽣内部错误（Internal Error）的有效请求数，除以这期间的有效请求总数。
image.png
例如，我们在⼀分钟内发送100个有效请求到系统中，其中有5个请求导致系统返回内部错误，那我们可以说这⼀分钟系统的错误率是 5 / 100 = 5%。
下⾯，我想带你看看硅⾕⼀线公司所搭建的架构平台的准确性SLA。
Google Cloud Platform的SLA中，有着这样的准确性定义：每个⽉系统的错误率超过5%的时间要少于0.1%，以每分钟为单位来计算。
⽽亚马逊AWS云计算平台有着稍微不⼀样的准确性定义：以每5分钟为单位，错误率不会超过0.1%。
你看，我们可以⽤错误率来定义准确性，但具体该如何评估系统的准确性呢？⼀般来说，我们可以采⽤性能测试（Performance Test）或者是查看系统⽇志（Log）两种⽅法来评估。
具体的做法我会在后⾯展开讲解，今天你先理解这项指标就可以了。</p>
<h1> 3. 系统容量（Ca pa c ity）</h1>
<p>在数据处理中，系统容量通常指的是系统能够⽀持的预期负载量是多少，⼀般会以每秒的请求数为单位来表⽰。
我们常常可以看见，某个系统的架构可以处理的QPS （Queries Per Second）是多少⼜或者RPS（Requests Per Second）是多少。这⾥的QPS或者是RPS就是指系统每秒可以响应多少请求数。
我们来看看之前Twitter发布的⼀项数据，Twitter系统可以响应30万的QPS来读取Twitter Timelines。这⾥Twitter系统给出的就是他们对于系统容量（Capacity）的SLA。
你可能会问，我要怎么给⾃⼰设计的系统架构定义出准确的QPS呢？以我的经验看，可以有下⾯这⼏种⽅式。
第⼀种，是使⽤限流（Throttling）的⽅式。
如果你是使⽤Java语⾔进⾏编程的，就可以使⽤Google Guava库中的RateLimiter类来定义每秒最多发送多少请求到后台处理。
假设我们在每台服务器都定义了⼀个每秒最多处理1000个请求的RateLimiter，⽽我们有N台服务器，在最理想的情况下，我们的QPS可以达到1000 * N。
这⾥要注意的雷区是，这个请求数并不是设置得越多越好。因为每台服务器的内存有限，过多的请求堆积在服务器中有可能会导致内存溢出
（Out-Of-Memory）的异常发⽣，也就是所有请求所需要占⽤的内存超过了服务器能提供的内存，从⽽让整个服务器崩溃。
第⼆种，是在系统交付前进⾏性能测试（Performance Test）。
我们可以使⽤像Apache JMeter⼜或是LoadRunner这类型的⼯具对系统进⾏性能测试。这类⼯具可以测试出系统在峰值状态下可以应对的QPS 是多少。
当然了，这⾥也是有雷区的。
有的开发者可能使⽤同⼀类型的请求参数，导致后台服务器在多数情况下命中缓存（Cache Hit）。这个时候得到的QPS可能并不是真实的QPS。
打个⽐⽅，服务器处理请求的正常流程需要查询后台数据库，得到数据库结果后再返回给⽤户，这个过程平均需要1秒。在第⼀次拿到数据库结果后，这个数据就会被保存在缓存中，⽽如果后续的请求都使⽤同⼀类型的参数，导致结果不需要从数据库得到，⽽是直接从缓存中得到，这个过程我们假设只需要0.1秒。那这样，我们所计算出来的QPS就会⽐正常的⾼出10倍。所以在⽣成请求的时候，要格外注意这⼀点。
第三种，是分析系统在实际使⽤时产⽣的⽇志（Log）。
系统上线使⽤后，我们可以得到⽇志⽂件。⼀般的⽇志⽂件会记录每个时刻产⽣的请求。我们可以通过系统每天在最繁忙时刻所接收到的请求数，
来计算出系统可以承载的QPS。
不过，这种⽅法不⼀定可以得到系统可以承载的最⼤QPS。
在这⾥打个⽐喻，⼀家可以容纳上百桌客⼈的餐馆刚开业，因为客流量还⽐较⼩，在每天最繁忙的时候只接待了10桌客⼈。那我们可以说这家餐馆最多只能接待10桌客⼈吗？不可以。
同样的，以分析系统⽇志的⽅法计算出来的QPS并不⼀定是服务器能够承载的最⼤QPS。想要得到系统能承受的最⼤QPS，更多的是性能测试和⽇志分析相结合的⼿段。</p>
<h1> 4. 延迟（Latency）</h1>
<p>延迟指的是系统在收到⽤户的请求到响应这个请求之间的时间间隔。
在定义延迟的SLA时，我们常常看到系统的SLA会有p95或者是p99这样的延迟声明。这⾥的p指的是percentile，也就是百分位的意思。如果说⼀个系统的p95 延迟是1秒的话，那就表⽰在100个请求⾥⾯有95个请求的响应时间会少于1秒，⽽剩下的5个请求响应时间会⼤于1秒。
下⾯我们⽤⼀个具体的例⼦来说明延迟这项指标在SLA中的重要性。
假设，我们已经设计好了⼀个社交软件的系统架构。这个社交软件在接收到⽤户的请求之后，需要读取数据库中的内容返回给⽤户。
为了降低系统的延迟，我们会将数据库中内容放进缓存（Cache）中，以此来减少数据库的读取时间。在系统运⾏了⼀段时间后，我们得到了⼀些缓存命中率（Cache Hit Ratio）的信息。有90%的请求命中了缓存，⽽剩下的10%的请求则需要重新从数据库中读取内容。
这时服务器所给我们的p95或者p99延迟恰恰就衡量了系统的最长时间，也就是从数据库中读取内容的时间。作为⼀个优秀架构师，你可以通过改进缓存策略从⽽提⾼缓存命中率，也可以通过优化数据库的Schema或者索引（Index）来降低p95或p99 延迟。
总⽽⾔之，当p95或者p99过⾼时，总会有5%或者1%的⽤户抱怨产品的⽤户体验太差，这都是我们要通过优化系统来避免的。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>