<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Fri, 28 Jul 2023 15:31:04 GMT</pubDate>
    <lastBuildDate>Fri, 28 Jul 2023 15:31:04 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>redis</category>
    <category>算法 链表</category>
    <category>算法</category>
    <category>JVM</category>
    <item>
      <title>Redis 为什么这么快？</title>
      <link>https://merryldt.github.io/moyu/redis/04_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/04_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Redis 为什么这么快？</source>
      <description>概述 根据官⽅数据，Redis 的 QPS 可以达到约 100000（每秒请求数）; 横轴是连接数，纵轴是 QPS 基于内存实现 Redis 是基于内存的数据库，想对于磁盘来说,速度快了很多。 磁盘和内存的区别： 访问速度 内存是电子存储介质，可以在纳秒级别（10-9秒）的时间内完成读写操作。而磁盘是机械设备，需要寻找和移动读写头，这会导致较高的延迟，通常在毫秒级别（10-3秒）或更长的时间内完成读写。 物理性能 内存芯片位于计算机主板上，与处理器之间的距离非常近，数据传输路径很短。而磁盘通常是通过数据线连接到主板，数据传输路径较长，因此内存的物理性能更高。</description>
      <category>redis</category>
      <pubDate>Fri, 28 Jul 2023 11:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>根据官⽅数据，Redis 的 QPS 可以达到约 100000（每秒请求数）;</p>
<figure><figcaption>横轴是连接数，纵轴是 QPS</figcaption></figure>
<h2> 基于内存实现</h2>
<p>Redis 是基于内存的数据库，想对于磁盘来说,速度快了很多。</p>
<blockquote>
<blockquote>
<p>磁盘和内存的区别：</p>
<ol>
<li>访问速度<br>
内存是电子存储介质，可以在纳秒级别（10<sup>-9秒）的时间内完成读写操作。而磁盘是机械设备，需要寻找和移动读写头，这会导致较高的延迟，通常在毫秒级别（10</sup>-3秒）或更长的时间内完成读写。</li>
<li>物理性能<br>
内存芯片位于计算机主板上，与处理器之间的距离非常近，数据传输路径很短。而磁盘通常是通过数据线连接到主板，数据传输路径较长，因此内存的物理性能更高。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="3">
<li>读写方式<br>
内存以随机存取的方式工作，可以直接通过内存地址访问任何数据。这使得内存的读写速度不受数据位置的影响。磁盘则需要按照物理磁道上的顺序读取数据，因此在读取大量非连续数据时会有明显的性能下降。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="4">
<li>缓存<br>
现代计算机通常配备高速缓存，其中包括一级缓存（L1 Cache）和二级缓存（L2 Cache）。这些缓存通常位于处理器内部，速度更快，作为内存和处理器之间的缓冲区域，可以加快数据的访问速度。相比之下，磁盘并不具备这样的缓存功能</li>
</ol>
</blockquote>
</blockquote>
<h2> ⾼效的数据结构</h2>
<p>Redis ⼀共有 5 种数据类型， String、List、Hash、Set、SortedSet<br>
不同的数据类型底层使⽤了⼀种或者多种数据结构来⽀撑，⽬的就是为了追求更快的速度。</p>
<figure><figcaption>Alt text</figcaption></figure>
<ul>
<li>SDS 简单动态字符串优势</li>
<li>zipList 压缩列表</li>
<li>quicklist</li>
<li>skipList 跳跃表</li>
<li>整数数组（intset）</li>
</ul>
<h2> 线程模型</h2>
<h3> 6.0之前的单线程模型</h3>
<ul>
<li>
<p>Redis 的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。但Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。</p>
</li>
<li>
<p>单线程的好处</p>
<ol>
<li>避免线程创建过多导致的性能消耗，反而降低整体吞吐能力。</li>
<li>避免上下文切换引起的 CPU 额外的开销。</li>
<li>避免了线程之间的竞争问题，如加锁、解锁、死锁等，都会造成性能损耗。</li>
<li>无需额外考虑多线程带来的程序复杂度，代码更清晰，处理逻辑简单。</li>
</ol>
</li>
</ul>
<h3> 6.0之后的多线程</h3>
<ul>
<li>
<p>底层网络硬件性能越来越好，Redis 的性能瓶颈逐渐体现在网络 I/O 的读写上，单个线程处理网络 I/O 读写的速度跟不上底层网络硬件执行的速度。</p>
</li>
<li>
<p>6.0之后的多线程主要解决什么问题 ?</p>
<ul>
<li>可以充分利用服务器CPU的多核资源，而主线程明显只能利用一个</li>
<li>多线程任务可以分摊 Redis 同步 IO 读写负荷，降低耗时</li>
</ul>
</li>
</ul>
<h2> I/O 多路复⽤模型</h2>
<p>Redis 采⽤ I/O 多路复⽤技术，并发处理连接。采⽤了 epoll + ⾃⼰实现的简单的事件框架。</p>
<p>epoll 中的读、写、关闭、连接都转化成了事件，然后利⽤ epoll 的多路复⽤特性，绝不在IO上浪费⼀点时间</p>
<h2> 高性能总结：</h2>
<ol>
<li>基于内存实现，而非磁盘，大都是简单的存取操作，资源主要消耗在 IO 上，所以读取速度快。</li>
<li>数据结构：基于不同业务场景的高效数据结构
<ul>
<li>动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)</li>
<li>双端列表(REDIS_ENCODING_LINKEDLIST)</li>
<li>压缩列表(REDIS_ENCODING_ZIPLIST)</li>
<li>跳跃表(REDIS_ENCODING_SKIPLIST)</li>
<li>哈希表(REDIS_HASH)</li>
<li>整数集合(REDIS_ENCODING_INTSET)</li>
</ul>
</li>
<li>线程模型：6.0之前 Redis 的网络 IO 以及键值对指令读写是由单个线程来执行的，避免了不必要的contextswitch和竞选；6.0 之后多线程分摊 Redis 同步 IO 读写负荷，降低耗时。</li>
<li>I/O 模型：基于I/O多路复用模型，非阻塞的I/O模型</li>
<li>恰单的数据编码：根据实际数据类型，选择合理的数据编码</li>
<li>Redis 本身是一个全局 哈希表，他的时间复杂度是 O(1)，另外为了防止哈希冲突导致链表过长，执行 rehash 操作进行扩充，减少哈希冲突。</li>
</ol>
<h2> 内存与磁盘</h2>
<p>主要原因
内存（RAM）的读写速度比磁盘（硬盘或固态硬盘）快的主要原因有以下几点：</p>
<p>访问速度</p>
<p>内存是电子存储介质，可以在纳秒级别（10<sup>-9秒）的时间内完成读写操作。而磁盘是机械设备，需要寻找和移动读写头，这会导致较高的延迟，通常在毫秒级别（10</sup>-3秒）或更长的时间内完成读写。</p>
<p>电子存储介质，如固态硬盘（SSD）和闪存驱动器（USB闪存驱动器），使用闪存芯片来存储数据。这些芯片基于电子器件，如晶体管和电容器，通过在芯片内部存储和读取电荷量来表示数据。电子存储介质的主要优势在于它们可以通过直接读取或写入电荷来快速访问数据，而无需移动部件。</p>
<p>相比之下，机械存储介质，如硬盘驱动器（HDD），使用旋转磁盘和移动的读写头来存储和检索数据。当读取或写入数据时，硬盘必须旋转磁盘以定位所需的数据，并将读写头移动到正确的位置。这种机械运动导致了存取数据的延迟，限制了机械存储介质的速度。</p>
<p>物理性能</p>
<p>内存芯片位于计算机主板上，与处理器之间的距离非常近，数据传输路径很短。而磁盘通常是通过数据线连接到主板，数据传输路径较长，因此内存的物理性能更高。</p>
<p>读写方式</p>
<p>内存以随机存取的方式工作，可以直接通过内存地址访问任何数据。这使得内存的读写速度不受数据位置的影响。磁盘则需要按照物理磁道上的顺序读取数据，因此在读取大量非连续数据时会有明显的性能下降。</p>
<p>内存的读写方式：</p>
<p>读取：CPU通过内存总线从内存中读取数据。读取速度非常快，因为内存是直接与CPU连接的，可以实现几纳秒级的读取速度。
写入：CPU通过内存总线将数据写入内存。写入速度也很快，但通常比读取速度稍慢一些。
内存总线（Memory Bus）是计算机系统中用于传输数据和指令到和从内存（RAM）中的一组电路和信号线。它连接了中央处理器（CPU）和内存之间，允许CPU与内存进行数据交换。</p>
<p>内存总线负责在CPU和内存之间传输数据的工作。当CPU需要从内存中读取数据时，它会向内存总线发送读取请求，并指定要读取的内存地址。内存总线将传输该请求到内存中，并将请求的数据返回给CPU。</p>
<p>类似地，当CPU需要将数据写入内存时，它会向内存总线发送写入请求，并将要写入的数据和目标内存地址传输给内存。内存总线将确保数据正确地写入到指定的内存地址。</p>
<p>内存总线的宽度是其重要的特性之一，它决定了一次可以传输多少位（或字节）的数据。例如，一个16位的内存总线可以在每个时钟周期中传输16位（2字节）的数据，而一个32位的内存总线可以传输32位（4字节）的数据。</p>
<p>内存总线的速度也是关键因素之一，它决定了数据传输的快慢。速度通常以兆赫兹（MHz）或千兆赫兹（GHz）为单位进行衡量。较高的内存总线速度可以提供更快的数据传输速度，从而提高计算机系统的整体性能。</p>
<p>磁盘的读写方式：</p>
<p>读取：磁盘驱动器通过机械臂和磁头访问磁盘上的数据。读取速度较慢，因为需要定位和移动机械臂以及等待磁盘旋转到正确的位置。读取速度通常以每秒几十至几百兆字节为单位。
写入：磁盘驱动器将数据写入磁盘的空闲区域。写入速度与读取速度相当，但可能会受到磁盘上数据碎片的影响，以及文件系统的写入策略（如写缓存）。
磁盘臂是磁盘驱动器中的一个机械臂，它支持磁头的运动。磁盘臂的作用是定位和移动磁头到特定的磁道（track）上。磁道是磁盘上的一个圆形轨道，数据存储在磁道上。</p>
<p>磁头是磁盘驱动器中的一个感应元件，用于读取和写入数据。磁头通过与磁盘表面的磁性材料相互作用来完成数据的读取和写入操作。读取操作涉及通过感应磁场来解读磁盘上存储的数据，而写入操作则涉及改变磁盘表面的磁性以存储新的数据。</p>
<p>磁盘臂和磁头的协同工作使得磁盘驱动器能够在磁道上读取和写入数据。当需要读取或写入特定数据时，磁盘臂会移动磁头到相应的磁道上，然后磁头会与磁盘表面进行交互，执行读取或写入操作。</p>
<p>缓存</p>
<p>现代计算机通常配备高速缓存，其中包括一级缓存（L1 Cache）和二级缓存（L2 Cache）。这些缓存通常位于处理器内部，速度更快，作为内存和处理器之间的缓冲区域，可以加快数据的访问速度。相比之下，磁盘并不具备这样的缓存功能：</p>
<p>1）速度：磁盘相比于CPU缓存的访问速度非常慢。CPU缓存是位于CPU芯片内部或者紧邻CPU的高速缓存，其访问速度非常快，可以以纳秒级的速度读取和写入数据。相比之下，磁盘是一种机械存储设备，需要旋转磁盘和机械臂移动来读取和写入数据，其访问速度通常以毫秒级别计算。这种速度差异非常大，无法满足CPU对高速缓存的要求。</p>
<p>2）高并发性能：CPU缓存需要支持高并发的访问，因为多个CPU核心可能同时访问缓存。而磁盘通常只支持有限的并发访问，无法满足多个CPU核心同时访问的需求。</p>
<p>3）电源开销：CPU缓存位于CPU芯片内部或者紧邻CPU，与CPU共享同一个电源供应。这样可以确保缓存的电源开销较低，因为电源供应和CPU之间的距离非常近。相比之下，磁盘通常连接在计算机的主板上，与CPU之间的距离较远，需要额外的电源供应和数据线连接。这样会增加系统的电源开销和复杂性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>缓存击穿、穿透、雪崩</title>
      <link>https://merryldt.github.io/moyu/redis/03_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/03_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">缓存击穿、穿透、雪崩</source>
      <description>1 一、缓存击穿（热点失效） 原因: 缓存不存在 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 过期时间再加⼀个随机值。设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }</description>
      <category>redis</category>
      <pubDate>Thu, 27 Jul 2023 17:43:37 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1</h1>
<h2> 一、缓存击穿（热点失效）</h2>
<h3> 原因: 缓存不存在</h3>
<ul>
<li>背景: 缓存被删除或者失效</li>
<li>现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。</li>
<li>关键字：单⼀热点数据、⾼并发、数据失效</li>
<li>描述：
⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。</li>
</ul>
<h3> 解决方案：</h3>
<ol>
<li>
<p>过期时间 + 随机值</p>
<p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。<br>
过期时间再加⼀个随机值。设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒</p>
</li>
<li>
<p>预热<br>
分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。</p>
</li>
<li>
<p>加锁</p>
<ul>
<li>当发现缓存失效的时候，不是⽴即从数据库加载数据。</li>
<li>⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。</li>
<li>这样只让⼀个请求去数据库读取数据</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 二、缓存穿透(不存在)</h2>
<h3> 原因：数据在【缓存和数据库】中不存在</h3>
<p>缓存穿透：意味着有特殊请求在查询⼀个<strong>不存在的数据</strong>，即不数据存在 Redis 也不存在于数据库。
导致每次请求都会穿透到数据库，缓存成了摆设，对数据库产⽣很⼤压⼒从⽽影响正常服务。</p>
<figure><figcaption>Alt text</figcaption></figure>
<h3> 解决⽅案</h3>
<ul>
<li>缓存空值：当请求的数据不存在 Redis 也不存在数据库的时候，设置⼀个缺省值（⽐如：None）。当后续再次进⾏查询则直接返回空值或者缺省值。</li>
<li>布隆过滤器：在数据写⼊数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据⼀定没有在数据库中保存，就不要去数据库查询了
<strong>布隆过滤器</strong>
BloomFilter 要缓存全量的 key，这就要求全量的 key 数量不⼤，10 亿 条数据以内最佳，因为 10 亿 条数据⼤概要占⽤ 1.2GB 的内存。</li>
</ul>
<h2> 三、缓存雪崩（大面积失效）</h2>
<p>缓存雪崩指的是⼤量的请求⽆法在 Redis 缓存系统中处理，请求全部打到数据库，导致数据库压⼒激增，甚⾄宕
机。
出现该原因主要有两种：</p>
<ul>
<li>⼤量热点数据同时过期，导致⼤量请求需要查询数据库并写到缓存；</li>
<li>Redis 故障宕机，缓存系统异常。</li>
</ul>
<h3> 原因一：<strong>缓存⼤量数据同时过期</strong></h3>
<p>数据保存在缓存系统并设置了过期时间，但是由于在同时⼀刻，⼤量数据同时过期。<br>
系统就把请求全部打到数据库获取数据，并发量⼤的话就会导致数据库压⼒激增。<br>
缓存雪崩是发⽣在⼤量数据同时失效的场景，⽽缓存击穿（失效）是在某个热点数据失效的场景，这是他们最⼤的区别。</p>
<figure><figcaption>Alt text</figcaption></figure>
<h3> 原因一：解决⽅案</h3>
<ol>
<li>
<p>过期时间添加随机值
要避免给⼤量的数据设置⼀样的过期时间，过期时间 = baes 时间+ 随机时间（较⼩的随机数，⽐如随机增加 1~5分钟）。<br>
这样⼀来，就不会导致同⼀时刻热点数据全部失效，同时过期时间差别也不会太⼤，既保证了相近时间失效，⼜能满⾜业务需求。</p>
</li>
<li>
<p>接⼝限流
当访问的不是核⼼数据的时候，在查询的⽅法上加上接⼝限流保护。⽐如设置 10000 req/s。<br>
如果访问的是核⼼数据接⼝，缓存不存在允许从数据库中查询并设置到缓存中。<br>
这样的话，只有部分请求会发送到数据库，减少了压⼒。<br>
限流，就是指，我们在业务系统的请求⼊⼝前端控制每秒进⼊系统的请求数，避免过多的请求被发送到数据库。</p>
<p><strong>实现方式</strong>:</p>
<ol>
<li>滑动窗口；</li>
</ol>
<figure><figcaption>接⼝限流</figcaption></figure>
</li>
</ol>
<h3> 原因二：<strong>Redis 故障宕机</strong></h3>
<p>⼀个 Redis 实例能⽀撑 10 万的 QPS，⽽⼀个数据库实例只有 1000 QPS。<br>
⼀旦 Redis 宕机，会导致⼤量请求打到数据库，从⽽发⽣缓存雪崩。</p>
<h3> 原因二： 解决方案：</h3>
<p>对于缓存系统故障导致的缓存雪崩的解决⽅案有两种：</p>
<ul>
<li>服务熔断和接⼝限流；</li>
<li>构建⾼可⽤缓存集群系统。</li>
</ul>
<h4> 服务</h4>
<p><strong>服务熔断和限流</strong></p>
<p>在业务系统中，针对⾼并发的使⽤服务熔断来有损提供服务从⽽保证系统的可⽤性。
服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防⽌所有流量打到数据库导致宕机。
服务熔断和限流属于在发⽣了缓存雪崩，如何降低雪崩对数据库造成的影响的⽅案。</p>
<p><strong>构建⾼可⽤的缓存集群</strong></p>
<p>所以，缓存系统⼀定要构建⼀套 Redis ⾼可⽤集群，⽐如 《Redis 哨兵集群》或者 《Redis Cluster 集群》，如果Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机⽽导致的缓存雪崩问题。</p>
<h2> 总结</h2>
<ul>
<li>缓存穿透指的是数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</li>
<li>缓存击穿（失效）指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被
击穿了，请求直奔数据库。</li>
<li>缓存雪崩指的是⼤量的热点数据⽆法在 Redis 缓存中处理（⼤⾯积热点数据缓存失效、Redis 宕机），流量全部打到数据库，导致数据库极⼤压⼒。</li>
</ul>
<h2> 思考</h2>
]]></content:encoded>
    </item>
    <item>
      <title>讲讲 Redis 缓存更新一致性</title>
      <link>https://merryldt.github.io/moyu/redis/02_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/02_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">讲讲 Redis 缓存更新一致性</source>
      <description>自己使用的场景 通常我们是先从缓存中读取,如果有,返回；如果没有,则从数据库中读取，返回写入缓存,设置缓存时间,并返回。 代码如下： public String getUserName(Integer userId){ // 因为key 通常会加一些前缀，作为指定作用的key; 这里id实际是userId. String userIdkey = &amp;quot;redis:userId:&amp;quot;+userId; String userName = redis.get(userIdkey); int cacheTimeSin = 60; if(StringUtils.isNotEmppty()){ return userName; } userName = userMapper.getOne(1); redis.set(userIdkey,userName,cacheTimeSin, TimeUnit.SECONDS); return userName; }</description>
      <category>redis</category>
      <pubDate>Thu, 27 Jul 2023 14:40:18 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 自己使用的场景</h2>
<p>通常我们是先从缓存中读取,如果有,返回；如果没有,则从数据库中读取，返回写入缓存,设置缓存时间,并返回。<br>
代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写到这里是不是发现还会有一个问题？就是如果 userName 在其他地方更新了呢？ 所以一定还有一段：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想一想，如果这两个操作是两个线程操作？并且交叉操作呢？会发生什么问题？</p>
<h2> 在使用redis作为缓存时,写操作</h2>
<p>当执行写操作后，因为需要保证从缓存读取到的数据与数据库中的数据是一致的，这就需要对缓存进行更新。</p>
<h2> 旧key 是删除还是更新？缓存和数据库的更新顺序？</h2>
<ol>
<li>想想，自己目前使用的方式是什么？</li>
<li>想想，还有什么方式？以及对比自己使用的，优劣对比？</li>
</ol>
<h2> 四大策略</h2>
<h3> 1. 先删除缓存，再更新数据库</h3>
<ul>
<li>并发问题:</li>
</ul>
<blockquote>
<blockquote>
<p>写： 线程张三<br>
读： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"></td>
<td style="text-align:right">缓存失效</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">从数据库读取数据为v1</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">更新数据库为v2</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"></td>
<td style="text-align:right">将v1写入缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h3> 2. 先更新数据库，再删除缓存</h3>
<ol>
<li>若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。</li>
<li>并发问题:</li>
</ol>
<blockquote>
<blockquote>
<p>读： 线程张三<br>
写： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">缓存失效</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">从数据库读取数据为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库</td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">删除缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">写入缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h3> 3. 先更新缓存，再更新数据库</h3>
<ol>
<li>缓存更新成功，数据库有更新失败的风险；导致最新的数据未持久化，风险很高。</li>
<li>并发问题。</li>
</ol>
<blockquote>
<blockquote>
<p>写： 线程张三<br>
写： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">更新缓存为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v1</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新缓存为v2</td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">更新数据库为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right">v2</td>
</tr>
</tbody>
</table>
<h3> 4. 先更新数据库，再更新缓存</h3>
<ol>
<li>同删除缓存策略一样，若数据库更新成功缓存更新失败则会造成数据不一致问题。</li>
<li>并发问题。</li>
</ol>
<blockquote>
<blockquote>
<p>写： 线程张三<br>
写： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">更新缓存为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新缓存为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">更新数据库为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h2> 对于旧key,目前已知的两种策略</h2>
<ol>
<li>删除失效缓存: 读取时会因为未命中缓存而从数据库中读取新的数据并更新到缓存中</li>
<li>更新缓存: 直接将新的数据写入缓存覆盖过期数据</li>
</ol>
<h2> 更新缓存和数据库的前后顺序，也有两种</h2>
<ol>
<li>先数据库后缓存</li>
<li>先缓存后数据库</li>
</ol>
<h2> 总结,设计需要考虑的问题</h2>
<p>根据实际场景选择一款就行，折中；</p>
<h3> 对系统吞吐量的影响：</h3>
<p>比如更新缓存策略产生的数据库负载小于删除缓存策略的负载</p>
<h3> 并发安全性：</h3>
<p>并发读写时某些异常操作顺序可能造成数据不一致，如缓存中长期保存过时数据</p>
<h3> 更新失败的影响：</h3>
<p>若某个操作失败，如何对业务影响降到最小</p>
<h3> 检测和修复故障的难度:</h3>
<p>操作失败导致的错误会在日志留下详细的记录容易检测和修复。并发问题导致的数据错误没有明显的痕迹难以发现，且在流量高峰期更容易产生并发错误产生的业务风险较大。</p>
<h2> 如何解决以上并发导致的问题？</h2>
<h3> 1. 使用 CAS</h3>
<p>CAS (Check-And-Set 或 Compare-And-Swap)是一种常见的保证并发安全的手段。CAS 当且仅当客户端最后一次取值后该 key 没有被其他客户端修改的情况下，才允许当前客户端将新值写入。</p>
<ul>
<li>CAS 是一种乐观锁</li>
</ul>
<p>假如缓存初始值是v0,更新缓存的时候，必须要校验值等于v0，才去更新，否则放弃。</p>
<ul>
<li>目前已知的redis 提供CAS命令的中间件和redis官方支持的。</li>
</ul>
<blockquote>
<blockquote>
<ol>
<li>比如阿里的 Tair 以及腾讯的 Tendis。</li>
<li>Redis 官方提供了 Watch + 事务的方法来支持 CAS, 或者使用 redis 中 lua 脚本原子性执行的特点来实现 CAS。(比较复杂)</li>
</ol>
</blockquote>
</blockquote>
<h3> 2. 使用分布式锁</h3>
<ul>
<li>分布式锁是一种悲观锁</li>
</ul>
<blockquote>
<blockquote>
<ol>
<li>线程张三 拿到锁</li>
<li>线程张三操作</li>
<li>线程张三 释放锁</li>
<li>线程李四 拿到锁</li>
<li>线程李四操作</li>
<li>线程李四 释放锁</li>
</ol>
</blockquote>
</blockquote>
<p>可以解决并发问题，只是成本可能略高。</p>
<h3> 3. 延时双删</h3>
<ul>
<li>问题是: 读线程的写入缓存操作，发生于写线程的数据库数据更新之后。会发生缓存和数据库数据不一致的问题。</li>
<li>解决： 因为是读线程最后写入缓存，此时再清除缓存是不是就可以解决这个问题？<br>
延时双删就是写线程等待一段时间“确保”读线程都结束后再次删除缓存，以此清除可能的错误缓存数据。</li>
<li>需要注意的是: 因为无法确保读线程何时结束,所以仍有存在数据不一致的可能。</li>
</ul>
<p>但是延时双删实现成本很低而且极大的减少了并发问题出现的概率，不失为一种简单实用的手段。</p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"></td>
<td style="text-align:right">缓存失效</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">从数据库读取数据为v1</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">更新数据库为v2</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"></td>
<td style="text-align:right">将v1写入缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center">延时一段时间,删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h3> 4. 异步更新</h3>
<p>阿里开源了 MySQL 数据库binlog的增量订阅和消费组件 - canal。canal 模拟从库获得主库的 binlog 更新，然后将更新数据写入 MQ 或直接进行消费。<br>
我们可以让API服务器只负责写入数据库，另一个线程订阅数据库 binlog 增量进行缓存更新。<br>
因为 binlog 是有序的，因此可以避免两个写线程竞争。但我们仍然需要解决读写线程竞争的问题:</p>
<figure><figcaption>Alt text</figcaption></figure>
<h2> 实际场景中，你采用的是何种方式？</h2>
<h2> 这里可以延伸的问题？</h2>
<ol>
<li>如果使用的分布式锁，用的哪种？了解其原理不？</li>
<li>如果采用先删除缓存/缓存失效？导致大量请求到数据库？</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>双指针技巧</title>
      <link>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</guid>
      <source url="https://merryldt.github.io/rss.xml">双指针技巧</source>
      <description>七道题: 合并两个有序链表 链表的分解 合并 k 个有序链表 寻找单链表的倒数第 k 个节点 寻找单链表的中点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 合并两个有序链表 力扣</description>
      <category>算法 链表</category>
      <pubDate>Tue, 25 Jul 2023 00:32:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 七道题:</h2>
<ol>
<li>合并两个有序链表</li>
<li>链表的分解</li>
<li>合并 k 个有序链表</li>
<li>寻找单链表的倒数第 k 个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
<h3> 合并两个有序链表</h3>
<p>
<a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener noreferrer">力扣</a></p>

<h3> 单链表的分解</h3>
<p>
<a href="https://leetcode.cn/problems/partition-list/" target="_blank" rel="noopener noreferrer">力扣链接</a></p>

]]></content:encoded>
    </item>
    <item>
      <title>算法入门开始</title>
      <link>https://merryldt.github.io/moyu/algorithm/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">算法入门开始</source>
      <description>::: code-tabs#shell @tab pnpm pnpm create vuepress-theme-hope [dir] @tab yarn yarn create vuepress-theme-hope [dir] @tab npm npm init vuepress-theme-hope [dir] :::</description>
      <category>算法</category>
      <pubDate>Sat, 22 Jul 2023 11:47:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>::: code-tabs#shell</p>
<p>@tab pnpm</p>
<p>pnpm create vuepress-theme-hope [dir]
@tab yarn</p>
<p>yarn create vuepress-theme-hope [dir]
@tab npm</p>
<p>npm init vuepress-theme-hope [dir]
:::</p>
]]></content:encoded>
    </item>
    <item>
      <title>纯Java自带工具排查JVM</title>
      <link>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">纯Java自带工具排查JVM</source>
      <description>1. 获取java 进程的pid ps -ef | grep java jps 2. 使用jmap jmap -heap pid 获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。 root@iZuf64eg43tiam73abxiweZ:~# /usr/local/btjdk/jdk8/bin/jmap -heap 1028098 Attaching to process ID 1028098, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.71-b00 #1. using parallel threads in the new generation. using thread-local object allocation. Concurrent Mark-Sweep GC # 2. Heap Configuration: MinHeapFreeRatio = 40 MaxHeapFreeRatio = 70 MaxHeapSize = 4294967296 (4096.0MB) NewSize = 348913664 (332.75MB) MaxNewSize = 348913664 (332.75MB) OldSize = 3946053632 (3763.25MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB) #3. Heap Usage: New Generation (Eden + 1 Survivor Space): capacity = 314048512 (299.5MB) used = 166875944 (159.14530181884766MB) free = 147172568 (140.35469818115234MB) 53.136995598947465% used Eden Space: capacity = 279183360 (266.25MB) used = 132010792 (125.89530181884766MB) free = 147172568 (140.35469818115234MB) 47.28462040144513% used From Space: capacity = 34865152 (33.25MB) used = 34865152 (33.25MB) free = 0 (0.0MB) 100.0% used To Space: capacity = 34865152 (33.25MB) used = 0 (0.0MB) free = 34865152 (33.25MB) 0.0% used concurrent mark-sweep generation: capacity = 3946053632 (3763.25MB) used = 1832479232 (1747.58837890625MB) free = 2113574400 (2015.66162109375MB) 46.43827486630572% used 38355 interned Strings occupying 4029456 bytes.</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1. 获取java 进程的pid</h1>
<ol>
<li>ps -ef | grep java
</li>
<li>jps
</li>
</ol>
<h1> 2. 使用jmap</h1>
<h2> jmap -heap pid</h2>
<p>获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>第一部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用的是serial收集器（也叫串行收集器）即 Mark Sweep Compact GC。</li>
</ul>
<ol start="2">
<li>第二部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>MinHeapFreeRatio和MaxHeapFreeRatio: 设置堆的最小最大空闲比例。</li>
<li>MaxHeapSize: 堆的最大大小。</li>
<li>NewSize: 新生代的默认值。</li>
<li>MaxNewSize: 新生代的最大值</li>
<li>OldSize: 老年代的默认值。</li>
<li>NewRatio: 新生代和老年代的大小比例，即老年代:新生代=2:1,默认为2.</li>
<li>SurvivorRatio: 新生代中的eden区与survivor的比例=8:1.</li>
<li>MetaspaceSize: 1.8 开始叫元空间大小,使用本地内存的</li>
<li>CompressedClassSpaceSize: 类指针压缩空间大小, 默认为1G</li>
<li>MaxMetaspaceSize: 元空间的最大值。一般设置和MetaspaceSize一样大小。</li>
<li>G1HeapRegionSize: G1区块的大小, 取值为1M至32M. 其取值是要根据最小Heap大小划分出2048个区块</li>
</ul>
<ol start="3">
<li>第三部分:</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>新生代: 指eden加上一个survivor空间。容量有300M这样，使用了159M，还有140M空闲. 接近53%的使用率。（根据分代的思想，新生代都是一个eden 加上2个survivor）</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>单独的eden区: 大小为266M,使用125M,空闲140, 使用率47%</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>一个surivor区，是在使用着的</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另一个survivor的使用情况。此时没有被使用。和From Space 大小一致；</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>老年代： 总的大小是3763M，使用1747M,空闲2015M,使用率是46%。</li>
</ul>
<ol start="4">
<li>总结：
为java 进程分配了 4096M 的内存；
Eden Space + From Space + To Space + concurrent mark-sweep generation = 4096</li>
</ol>
<h1> 3. 使用jstat</h1>
<p>jstat -gc -t 1028098  60000 20</p>
<p>
从图中红框标记的的两条数据分析：</p>
<ul>
<li>一分钟采集1次gc 的数据，第一条和最后一条就是 19分钟。</li>
</ul>
<ol>
<li>GCT 总的gc 时间是 891.076秒</li>
<li>GCT 总的gc 时间是  895.115 秒
系统的吞吐量 = 1- （895.115-891.076）/ 19 *60   = 1- 0.0035  = 0.9965 = 99.65%</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>