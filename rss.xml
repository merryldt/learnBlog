<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Fri, 10 Nov 2023 02:53:31 GMT</pubDate>
    <lastBuildDate>Fri, 10 Nov 2023 02:53:31 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>JVM</category>
    <item>
      <title>使用Arthas 诊断代码-接口耗时越来越长,影响了业务实现</title>
      <link>https://merryldt.github.io/moyu/jvm/011_PracticeTow.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/011_PracticeTow.html</guid>
      <source url="https://merryldt.github.io/rss.xml">使用Arthas 诊断代码-接口耗时越来越长,影响了业务实现</source>
      <description>问题: 随着时间的增长，接口越来越慢,从1s的响应延长到10s 以上 @PostMapping(path=&amp;quot;/saveAnswer&amp;quot;) public String saveAnswer(@RequestBody AnswerInputo answerInputo){ System.out.println(&amp;quot;start save&amp;quot;); answerService.check(answerInputo); answerService.saveRecord(answerInputo); answerService.createOrder(answerInputo); answerService.save(answerInputo); System.out.println(&amp;quot;end save&amp;quot;); return &amp;quot;SUCCESS&amp;quot;; }</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 问题: 随着时间的增长，接口越来越慢,从1s的响应延长到10s 以上</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最初的想法是：添加日志,重新发版本</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 这样的问题：</h3>
<ol>
<li>添加的无用日志太多；</li>
<li>容易漏,导致关键的位置没有分析到；</li>
<li>因为此类问题大部分都是生产发现,线上如果调试,就需要不断发布,影响用户使用；</li>
</ol>
<h2> 使用 Arthas</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据提示，选择对应的java应用。
</p>
<h3> trace 命令指定追踪的类和方法</h3>
<p>输入要追踪的类和方法。输入格式为：trace {全限定类名} {方法名}：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 定位耗时部分</h4>
<ol>
<li>访问下controller中的callServices这个方法。这个时候arthas控制台有如下输出：</li>
</ol>
<p>
定位到service;</p>
<ol start="2">
<li>trace 命令service的方法。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>
</p>
<p>一目了然，可以看到是getTeamNumByTeamId() 方法耗时占比37%以上。</p>
<h3> trace 结合OGNL表达式 命令指定追踪的类和方法</h3>
<p>OGNL表达式，支持各种复杂的嵌套结构及比较逻辑.</p>
<h4> 根据参数筛选： 入参第一个参数等于 dd</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 根据运行时间筛选：耗时大于800ms</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> arthas 采集火焰图</h2>
<h3> 开始采集</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 查看采集的样本数量</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 停止采样</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><figcaption>Alt text</figcaption></figure>
<h3> 结果</h3>
<figure><figcaption>Alt text</figcaption></figure>
<p>【<strong>纵轴(Y轴)</strong>】表示的是方法调用的调用栈信息，即从最外层方法到最内层方法的调用信息。</p>
<p>【<strong>横轴(X轴)</strong>】表示的是方法调用的持续时间，即方法在执行过程中所占用的时间长度。</p>
<p>在一个火焰图中，越靠近下面的函数在x轴上越长是正常的，而越往上的函数就应该越短。所以，火焰图也像是一个个山峰。那么，如果火焰图出现较宽的峰顶，那就往往是性能瓶颈。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Arthas 入门</title>
      <link>https://merryldt.github.io/moyu/jvm/08001_ArthasOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/08001_ArthasOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Arthas 入门</source>
      <description>Arthas 全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 【开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。】 快速使用 arthas 执行arahas程序的用户需要和目标进程(即java应用)具有相同的权限 最好采用同一个用户执行： sudu su root</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Arthas</h2>
<p>全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p>
<p>【<strong>开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。</strong>】</p>
<h2> 快速使用 arthas</h2>
<p><strong>执行arahas程序的用户需要和目标进程(即java应用)具有相同的权限</strong>
最好采用同一个用户执行： sudu su root</p>
<h3> 例子</h3>
<ol>
<li>java 应用程序： math-game.jar</li>
<li>arthas 应用 arthas-boot.jar</li>
</ol>
<h3> 切换用户： sudo su root</h3>
<h3> 下载和启动java 应用程序</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 下载和启动arthas</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 选择java进程：</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>math-game进程是第 2 个，则输入 2，再输入回车/enter。Arthas 会 attach 到目标进程上，并输出日志</p>
<h4> 显示如下表示成功：</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： dashboard</h2>
<ul>
<li>功能 展示当前java进程的实时数据（线程、gc、jvm内存占用等）信息</li>
</ul>
<p>命令指导：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入dashboard，按回车/enter，会展示当前进程的信息，按ctrl+c可以中断执行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： thread</h2>
<ul>
<li>展示当前java进程详细的线程信息
目前java 部分程序使用的都是springboot,此类程序ID =1，通常是main函数</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>命令使用示例</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 命令： jad</h2>
<p>反编译类： demo.Mathgame</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> watch</h2>
<ul>
<li>观测某方法执行的详情
通过watch命令来查看demo.MathGame#primeFactors函数的返回值：</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> monitor</h2>
<ul>
<li>
<p>统计方法一段周期内的执行情况</p>
</li>
<li>
<p>命令</p>
</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 退出 arthas</h2>
<ul>
<li>
<p>quit 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</p>
</li>
<li>
<p>exit 等同于quit</p>
</li>
<li>
<p>stop 关闭 Arthas 服务端，所有 Arthas 客户端全部退出</p>
</li>
</ul>
<p>如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p>
<p>如果想完全退出 arthas，可以执行stop命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Arthas 实战使用</title>
      <link>https://merryldt.github.io/moyu/jvm/08002_ArthasTwo.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/08002_ArthasTwo.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Arthas 实战使用</source>
      <description>修改日志级别 修改指定类的日志级别 修改全局日志级别 # 查找到具体的类信息 sc -d *VipUserController # 使用ognl表达式查看日志属性的信息,判断日志级别 ognl -c classLoaderHash &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger&amp;quot; # 使用ognl表达式修改日志级别 ognl -c classLoaderHash &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&amp;quot; # 再次查看日志级别，判断是否修改成功 ognl &amp;quot;@com.learning.demo.arthas.controller.BaseUserController@logger&amp;quot; # 修改全局日志级别 ognl -c classLoaderHash &amp;apos;@org.slf4j.LoggerFactory@getLogger(&amp;quot;root&amp;quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&amp;apos;</description>
      <category>JVM</category>
      <pubDate>Fri, 10 Nov 2023 02:51:54 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 修改日志级别</h2>
<ul>
<li>修改指定类的日志级别</li>
<li>修改全局日志级别</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 更新代码、热加载</h2>
<ul>
<li>线上代码出现问题,想不重启,修改几行后，实现热加载。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编辑源码,修改后：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试,访问接口，查看结果</p>
<h2> 排查函数调用异常</h2>
<ul>
<li>观测方法执行异常具体信息，入参、出参等</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> arthas 后台异步执行诊断任务</h2>
<ul>
<li>执行dashboard、watch、trace等命令时，可将命令执行挂起，将结果输出到文件中，供后续分析，不影响其他命令执行。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 排查方法执行效率问题</h2>
<ul>
<li>线上某个接口执行慢，无法确定是哪一段代码的问题。可根据各方法执行耗时，缩小排查范围。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Kubernetes 组件</title>
      <link>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes 组件</source>
      <description>Kubernetes 组件 前提 部署完 Kubernetes，便拥有了一个完整的集群。 一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。 工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。 image.png 控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes 组件</h1>
<h2> 前提</h2>
<p>部署完 Kubernetes，便拥有了一个完整的集群。</p>
<p>一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。
工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。
在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。</p>
<p>image.png</p>
<h2> 控制平面组件（Control Plane Components）</h2>
<p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。
然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p>
<h3> kube-apiserver</h3>
<p>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<h3> etcd</h3>
<p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。</p>
<h3> kube-scheduler</h3>
<p>kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h3> kube-controller-manager</h3>
<p>kube-controller-manager 是控制平面的组件， 负责<strong>运行控制器进程</strong>。
从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。
例如:</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
<h3> cloud-controller-manager</h3>
<p>cloud-controller-manager 仅运行特定于云平台的控制器。
一个 Kubernetes 控制平面组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<h2> Node 组件</h2>
<p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h3> kubelet</h3>
<p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。
kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h3> kube-proxy</h3>
<p>kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。
kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。
如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<h3> Container Runtime</h3>
<p>容器运行环境是负责运行容器的软件。
Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。</p>
<h2> 插件(Addons)</h2>
<p>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p>
<h3> DNS</h3>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。
几乎所有 Kubernetes 集群都应该有集群 DNS。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Kubernetes API</title>
      <link>https://merryldt.github.io/moyu/k8s/05_Kubernetes_API.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/05_Kubernetes_API.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes API</source>
      <description>Kubernetes API Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。 Kubernetes API 使你可以在 Kubernetes 中查询和操纵 API 对象 （例如 Pod、Namespace、ConfigMap 和 Event）的状态。 操作工具 kubectl 命令行接口 kubeadm 持久化 Kubernetes 通过将序列化状态的对象写入到 etcd 中完成存储操作。</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes API</h1>
<p>Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</p>
<p>Kubernetes API 使你可以在 Kubernetes 中查询和操纵 API 对象 （例如 Pod、Namespace、ConfigMap 和 Event）的状态。</p>
<h2> 操作工具</h2>
<ul>
<li>kubectl 命令行接口</li>
<li>kubeadm</li>
</ul>
<h2> 持久化</h2>
<p>Kubernetes 通过将序列化状态的对象写入到 etcd 中完成存储操作。</p>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://merryldt.github.io/moyu/k8s/06_Cluster_Architecture.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/06_Cluster_Architecture.html</guid>
      <source url="https://merryldt.github.io/rss.xml"></source>
      <description>Nodes Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 Pod 所需的服务； 这些节点由控制面负责管理。 通常集群中会有若干个节点；而在一个学习所用或者资源受限的环境中，你的集群中也可能只有一个节点。 节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。 Communication between Nodes and the Control Plane 节点与控制面之间的通信,包括两种:</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Nodes</h2>
<p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 Pod 所需的服务； 这些节点由控制面负责管理。</p>
<p>通常集群中会有若干个节点；而在一个学习所用或者资源受限的环境中，你的集群中也可能只有一个节点。</p>
<p>节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。</p>
<h2> Communication between Nodes and the Control Plane</h2>
<p>节点与控制面之间的通信,包括两种:</p>
<ul>
<li>节点到控制面</li>
<li>控制面到节点</li>
</ul>
<h3> 节点到控制面</h3>
<p>Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从节点（或运行于其上的 Pod）发出的 API 调用都终止于 API 服务器。 其它控制面组件都没有被设计为可暴露远程服务。</p>
<h3> 控制面到节点</h3>
<p>从控制面（API 服务器）到节点有两种主要的通信路径。
第一种是从 API 服务器到集群中每个节点上运行的 kubelet 进程。
第二种是从 API 服务器通过它的代理功能连接到任何节点、Pod 或者服务。</p>
<h2> Controllers(控制器)</h2>
<p>在 Kubernetes 中，控制器通过监控集群 的公共状态，并致力于将当前状态转变为期望的状态。<br>
例如: 房间里的温度自动调节器<br>
当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。</p>
<h3> 控制器模式：</h3>
<ol>
<li>通过API服务器来控制；（job 控制器）</li>
<li>直接控制；</li>
</ol>
<h3> 设计</h3>
<p>作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。</p>
<h3> 运行控制器的方式</h3>
<ol>
<li>内置；运行在 kube-controller-manager 内。
Deployment 控制器和 Job 控制器是 Kubernetes 内置控制器的典型例子。</li>
<li>在控制面之外，用以扩展Kubernetes。</li>
</ol>
<h2> 租约（Lease）</h2>
<p>分布式系统通常需要租约（Lease）；租约提供了一种机制来锁定共享资源并协调集合成员之间的活动。 在 Kubernetes 中，租约概念表示为 <a href="http://coordination.k8s.io" target="_blank" rel="noopener noreferrer">coordination.k8s.io</a> API 组中的 Lease 对象， 常用于类似节点心跳和组件级领导者选举等系统核心能力。</p>
<h3> 节点心跳</h3>
<p>Kubernetes 使用 Lease API 将 kubelet 节点心跳传递到 Kubernetes API 服务器。对于每个 Node，在 kube-node-lease 名字空间中都有一个具有匹配名称的 Lease 对象。 在此基础上，每个 kubelet 心跳都是对该 Lease 对象的 update 请求，更新该 Lease 的 spec.renewTime 字段。 Kubernetes 控制平面使用此字段的时间戳来确定此 Node 的可用性。</p>
<h3> 领导者选举</h3>
<p>Kubernetes 也使用 Lease 确保在任何给定时间某个组件只有一个实例在运行。</p>
<h2> 云控制器管理器</h2>
<p>使用云基础设施技术，你可以在公有云、私有云或者混合云环境中运行 Kubernetes。 Kubernetes 的信条是基于自动化的、API 驱动的基础设施，同时避免组件间紧密耦合。
组件 cloud-controller-manager 是指云控制器管理器， 一个 Kubernetes 控制平面组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p>cloud-controller-manager 组件是基于一种插件机制来构造的， 这种机制使得不同的云厂商都能将其平台与 Kubernetes 集成。</p>
<h2> 关于 cgroup v2</h2>
<p>在 Linux 上，控制组约束分配给进程的资源。</p>
<p>kubelet 和底层容器运行时都需要对接 cgroup 来强制执行为 Pod 和容器管理资源， 这包括为容器化工作负载配置 CPU/内存请求和限制。</p>
<p>Linux 中有两个 cgroup 版本：cgroup v1 和 cgroup v2。cgroup v2 是新一代的 cgroup API。</p>
<h2> 容器运行时接口（CRI）</h2>
<p>container runtime： 容器运行时
CRI 是一个插件接口，它使 kubelet 能够使用各种容器运行时，无需重新编译集群组件。
你需要在集群中的每个节点上都有一个可以正常工作的容器运行时， 这样 kubelet 能启动 Pod 及其容器。</p>
<p>容器运行时接口（CRI）是 kubelet 和容器运行时之间通信的主要协议。</p>
<p>Kubernetes 容器运行时（container runtime）接口（Container Runtime Interface；CRI）定义了主要 gRPC 协议， 用于集群组件 kubelet 和容器运行时之间的通信。</p>
<h2> 垃圾收集</h2>
<p>垃圾收集（Garbage Collection）是 Kubernetes 用于清理集群资源的各种机制的统称。</p>
<ul>
<li>终止的 Pod</li>
<li>已完成的 Job</li>
<li>不再存在属主引用的对象</li>
<li>未使用的容器和容器镜像</li>
<li>动态制备的、StorageClass 回收策略为 Delete 的 PV 卷</li>
<li>阻滞或者过期的 CertificateSigningRequest (CSR)</li>
<li>在以下情形中删除了的节点对象：
<ol>
<li>当集群使用云控制器管理器运行于云端时；</li>
<li>当集群使用类似于云控制器管理器的插件运行在本地环境中时。</li>
</ol>
</li>
<li>节点租约对象</li>
</ul>
<h2> 混合版本代理（Mixed Version Proxy）</h2>
<p>Kubernetes 1.28 包含了一个 Alpha 特性，可以让 API 服务器代理指向其他对等 API 服务器的资源请求。当一个集群中运行着多个 API 服务器，且各服务器的 Kubernetes 版本不同时 （例如在上线 Kubernetes 新版本的时间跨度较长时），这一特性非常有用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>概述</title>
      <link>https://merryldt.github.io/moyu/k8s/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">概述</source>
      <description>概述 Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 k8s 的崛起理由 Alt text 传统部署时代： 早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序， 而且维护许多物理服务器的成本很高。</description>
      <pubDate>Mon, 21 Aug 2023 12:17:04 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 概述</h1>
<p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。</p>
<h2> k8s 的崛起理由</h2>
<figure><figcaption>Alt text</figcaption></figure>
<h3> 传统部署时代：</h3>
<p>早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序， 而且维护许多物理服务器的成本很高。</p>
<h3> 虚拟化部署时代：</h3>
<p>因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。</p>
<p>虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。</p>
<p>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p>
<h3> 容器部署时代：</h3>
<p>容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p>
<p>容器因具有许多优势而变得流行起来，例如：</p>
<ul>
<li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。</li>
<li>关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。</li>
<li>可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li>跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。</li>
<li>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li>
<li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li>
<li>资源隔离：可预测的应用程序性能。</li>
<li>资源利用：高效率和高密度。</li>
</ul>
<h3> 当然,单个容器很方便,多个呢？是否需要管理</h3>
<p>Kubernetes。
Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary (金丝雀) 部署。</p>
<h2> Kubernetes 可以为我们提供</h2>
<h3> 服务发现和负载均衡</h3>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
<h3> 存储编排</h3>
<p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
<h3> 自动部署和回滚</h3>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
<h3> 自动完成装箱计算</h3>
<p>你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p>
<h3> 自我修复</h3>
<p>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p>
<h3> 密钥与配置管理</h3>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>
<h2> 总结</h2>
<p>Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。
Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Kubernetes 对象</title>
      <link>https://merryldt.github.io/moyu/k8s/02_duixiang.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/02_duixiang.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes 对象</source>
      <description>Kubernetes 对象 概述 在 Kubernetes 系统中，Kubernetes 对象是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。 具体而言，它们描述了如下信息： 哪些容器化应用正在运行（以及在哪些节点上运行） 可以被应用使用的资源 关于应用运行时行为的策略，比如重启策略、升级策略以及容错策略 Kubernetes 对象是一种“意向表达（Record of Intent）”。一旦创建该对象， Kubernetes 系统将不断工作以确保该对象存在。通过创建对象，你本质上是在告知 Kubernetes 系统，你想要的集群工作负载状态看起来应是什么样子的， 这就是 Kubernetes 集群所谓的期望状态（Desired State）。</description>
      <pubDate>Mon, 21 Aug 2023 12:17:04 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes 对象</h1>
<h2> 概述</h2>
<p>在 Kubernetes 系统中，Kubernetes 对象是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。</p>
<p>具体而言，它们描述了如下信息：</p>
<ul>
<li>哪些容器化应用正在运行（以及在哪些节点上运行）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时行为的策略，比如重启策略、升级策略以及容错策略</li>
</ul>
<p>Kubernetes 对象是一种“意向表达（Record of Intent）”。一旦创建该对象， Kubernetes 系统将不断工作以确保该对象存在。通过创建对象，你本质上是在告知 Kubernetes 系统，你想要的集群工作负载状态看起来应是什么样子的， 这就是 Kubernetes 集群所谓的期望状态（Desired State）。</p>
<p>操作 Kubernetes 对象 —— 无论是创建、修改或者删除 —— 需要使用 Kubernetes API。 比如，当使用 kubectl 命令行接口（CLI）时，CLI 会调用必要的 Kubernetes API； 也可以在程序中使用客户端库， 来直接调用 Kubernetes API。</p>
<h2> status 和 spec</h2>
<p>spec： 通俗的讲，就是创建Kubernetes 对象时设置的内容。比如：名字、有几个实例等。这些内容就是你对k8s 的期望状态 。
status:  当前状态。由 k8s  系统和组件设置并更新的。在任何时刻，k8s 控制平面 都一直在积极地管理着对象的实际状态，以使之达成期望状态。</p>
<p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，你可能会设置 Deployment 的 spec，指定该应用要有 3 个副本运行。 Kubernetes 系统读取 Deployment 的 spec， 并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统会通过执行修正操作来响应 spec 和 status 间的不一致 —— 意味着它会启动一个新的实例来替换。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>必需字段</p>
<p>在想要创建的 Kubernetes 对象所对应的 .yaml 文件中，需要配置的字段如下：</p>
<ul>
<li>apiVersion - 创建该对象所使用的 Kubernetes API 的版本</li>
<li>kind - 想要创建的对象的类别</li>
<li>metadata - 帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</li>
<li>spec - 你所期望的该对象的状态</li>
</ul>
<h2> Pod 对象</h2>
<p>最重要的 Kubernetes 基本对象 Pod。</p>
<p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod 是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。
Pod的内容始终是同地同步的，在共享上下文中运行。Pod建模为一个应用特定的“逻辑主机”:它包含一个或多个相对紧密耦合的应用容器。在非云上下文中，在同一台物理机或虚拟机上运行的应用程序类似于在同一台逻辑主机上运行的云应用程序。</p>
<h2> 什么是pod?</h2>
<p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。</p>
<p>Pod 类似于共享名字空间并共享文件系统卷的一组容器。</p>
<h2> Pod 示例</h2>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用pod</h2>
<p>Pod 通常不是直接创建的，而是使用工作负载资源创建的。</p>
<p>Kubernetes 集群中的 Pod 主要有两种用法：</p>
<ul>
<li>
<p>运行单个容器的 Pod。"每个 Pod 一个容器" 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</p>
</li>
<li>
<p>运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的 “边车”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。(相对高级，比较少使用)</p>
</li>
</ul>
<h2> Pod 怎样管理多个容器</h2>
<p>Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身。</p>
<h2> 管理一个或者多个 Pod 的工作负载资源</h2>
<h3> Deployment</h3>
<h3> StatefulSet</h3>
<h3> DaemonSet</h3>
]]></content:encoded>
    </item>
  </channel>
</rss>