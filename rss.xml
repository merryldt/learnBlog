<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Tue, 25 Jul 2023 00:34:24 GMT</pubDate>
    <lastBuildDate>Tue, 25 Jul 2023 00:34:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>算法 链表</category>
    <category>算法</category>
    <category>JVM</category>
    <item>
      <title>双指针技巧</title>
      <link>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</guid>
      <source url="https://merryldt.github.io/rss.xml">双指针技巧</source>
      <description>七道题: 合并两个有序链表 链表的分解 合并 k 个有序链表 寻找单链表的倒数第 k 个节点 寻找单链表的中点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 合并两个有序链表 力扣</description>
      <category>算法 链表</category>
      <pubDate>Tue, 25 Jul 2023 00:32:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 七道题:</h2>
<ol>
<li>合并两个有序链表</li>
<li>链表的分解</li>
<li>合并 k 个有序链表</li>
<li>寻找单链表的倒数第 k 个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
<h3> 合并两个有序链表</h3>
<p>
<a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener noreferrer">力扣</a></p>

]]></content:encoded>
    </item>
    <item>
      <title>算法入门开始</title>
      <link>https://merryldt.github.io/moyu/algorithm/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">算法入门开始</source>
      <description>::: code-tabs#shell @tab pnpm pnpm create vuepress-theme-hope [dir] @tab yarn yarn create vuepress-theme-hope [dir] @tab npm npm init vuepress-theme-hope [dir] :::</description>
      <category>算法</category>
      <pubDate>Sat, 22 Jul 2023 11:47:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>::: code-tabs#shell</p>
<p>@tab pnpm</p>
<p>pnpm create vuepress-theme-hope [dir]
@tab yarn</p>
<p>yarn create vuepress-theme-hope [dir]
@tab npm</p>
<p>npm init vuepress-theme-hope [dir]
:::</p>
]]></content:encoded>
    </item>
    <item>
      <title>纯Java自带工具排查JVM</title>
      <link>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">纯Java自带工具排查JVM</source>
      <description>1. 获取java 进程的pid ps -ef | grep java jps 2. 使用jmap jmap -heap pid 获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。 root@iZuf64eg43tiam73abxiweZ:~# /usr/local/btjdk/jdk8/bin/jmap -heap 1028098 Attaching to process ID 1028098, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.71-b00 #1. using parallel threads in the new generation. using thread-local object allocation. Concurrent Mark-Sweep GC # 2. Heap Configuration: MinHeapFreeRatio = 40 MaxHeapFreeRatio = 70 MaxHeapSize = 4294967296 (4096.0MB) NewSize = 348913664 (332.75MB) MaxNewSize = 348913664 (332.75MB) OldSize = 3946053632 (3763.25MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB) #3. Heap Usage: New Generation (Eden + 1 Survivor Space): capacity = 314048512 (299.5MB) used = 166875944 (159.14530181884766MB) free = 147172568 (140.35469818115234MB) 53.136995598947465% used Eden Space: capacity = 279183360 (266.25MB) used = 132010792 (125.89530181884766MB) free = 147172568 (140.35469818115234MB) 47.28462040144513% used From Space: capacity = 34865152 (33.25MB) used = 34865152 (33.25MB) free = 0 (0.0MB) 100.0% used To Space: capacity = 34865152 (33.25MB) used = 0 (0.0MB) free = 34865152 (33.25MB) 0.0% used concurrent mark-sweep generation: capacity = 3946053632 (3763.25MB) used = 1832479232 (1747.58837890625MB) free = 2113574400 (2015.66162109375MB) 46.43827486630572% used 38355 interned Strings occupying 4029456 bytes.</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1. 获取java 进程的pid</h1>
<ol>
<li>ps -ef | grep java
</li>
<li>jps
</li>
</ol>
<h1> 2. 使用jmap</h1>
<h2> jmap -heap pid</h2>
<p>获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>第一部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用的是serial收集器（也叫串行收集器）即 Mark Sweep Compact GC。</li>
</ul>
<ol start="2">
<li>第二部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>MinHeapFreeRatio和MaxHeapFreeRatio: 设置堆的最小最大空闲比例。</li>
<li>MaxHeapSize: 堆的最大大小。</li>
<li>NewSize: 新生代的默认值。</li>
<li>MaxNewSize: 新生代的最大值</li>
<li>OldSize: 老年代的默认值。</li>
<li>NewRatio: 新生代和老年代的大小比例，即老年代:新生代=2:1,默认为2.</li>
<li>SurvivorRatio: 新生代中的eden区与survivor的比例=8:1.</li>
<li>MetaspaceSize: 1.8 开始叫元空间大小,使用本地内存的</li>
<li>CompressedClassSpaceSize: 类指针压缩空间大小, 默认为1G</li>
<li>MaxMetaspaceSize: 元空间的最大值。一般设置和MetaspaceSize一样大小。</li>
<li>G1HeapRegionSize: G1区块的大小, 取值为1M至32M. 其取值是要根据最小Heap大小划分出2048个区块</li>
</ul>
<ol start="3">
<li>第三部分:</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>新生代: 指eden加上一个survivor空间。容量有300M这样，使用了159M，还有140M空闲. 接近53%的使用率。（根据分代的思想，新生代都是一个eden 加上2个survivor）</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>单独的eden区: 大小为266M,使用125M,空闲140, 使用率47%</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>一个surivor区，是在使用着的</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另一个survivor的使用情况。此时没有被使用。和From Space 大小一致；</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>老年代： 总的大小是3763M，使用1747M,空闲2015M,使用率是46%。</li>
</ul>
<ol start="4">
<li>总结：
为java 进程分配了 4096M 的内存；
Eden Space + From Space + To Space + concurrent mark-sweep generation = 4096</li>
</ol>
<h1> 3. 使用jstat</h1>
<p>jstat -gc -t 1028098  60000 20</p>
<p>
从图中红框标记的的两条数据分析：</p>
<ul>
<li>一分钟采集1次gc 的数据，第一条和最后一条就是 19分钟。</li>
</ul>
<ol>
<li>GCT 总的gc 时间是 891.076秒</li>
<li>GCT 总的gc 时间是  895.115 秒
系统的吞吐量 = 1- （895.115-891.076）/ 19 *60   = 1- 0.0035  = 0.9965 = 99.65%</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Jvm的内存结构和对象分配</title>
      <link>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Jvm的内存结构和对象分配</source>
      <description>图示 内存区域划分 JVM 内存区域 内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。 JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。 不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 线程 每个JVM只有一个Runtime实例。称为运行时环境。 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。） 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 图示</h1>
<figure><figcaption>内存区域划分</figcaption></figure>
<h1> JVM 内存区域</h1>
<ol>
<li>内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。</li>
<li>JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。</li>
<li>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li>
</ol>
<h2> 线程</h2>
<ol>
<li>每个JVM只有一个Runtime实例。称为运行时环境。</li>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li>
<li>在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。）</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li>
</ol>
<h3> 守护线程、普通线程</h3>
<h2> 一、程序计算器</h2>
<p>极小的内存空间,线程私有的,当前线程的行号指示器，程序的分支、循环、跳转、异常处理、线程恢复等基本功能都需要依赖程序计算器；比如(多线程切换)。<br>
线程执行的是:</p>
<ol>
<li>Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>Native方法，计数器值为空；</li>
</ol>
<p>值得注意的是它是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域</p>
<h2> 二、java虚拟机栈</h2>
<ol>
<li>
<p>虚拟机栈描述的是java方法执行的内存模型：线程私有的，生命周期与线程相同。</p>
</li>
<li>
<p>每个方法在执行的同时都会创建一个栈帧用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息；方法的调用直至执行完成的过程，对应着栈帧在虚拟机栈中<strong>入栈到出栈</strong>的过程。</p>
</li>
<li>
<p>虚拟机栈主要的部分是<strong>局部变量表</strong> ，其存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址);</p>
</li>
<li>
<p><u>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小</u>。</p>
</li>
<li>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出<strong>OutOfMemoryErro</strong>异常。</p>
</li>
</ol>
<h2> 三、本地方法栈</h2>
<p>与虚拟机栈作用类似，本地方法栈是虚拟机栈使用到的Native方法服务；SunHotSpot虚拟机把本地方法栈和虚拟机栈结合; 本地方法栈也会报虚拟机栈的两种异常。</p>
<h2> 四、java堆</h2>
<ol>
<li>
<p>java虚拟机管理的最大的一块内存；</p>
</li>
<li>
<p>所有线程共享的内存区域；</p>
</li>
<li>
<p>目的：存放对象实例，几乎所有的对象实例都在这里分配内存；（所有的对象实例以及数组都要在堆上分配）特别注意的是： 随着JIT编译器的发展与逃逸分析技术的成熟，<strong>栈上分配、标量替换优化技术</strong>带来了变化。不是所有对象都在堆上分配内存了。</p>
</li>
<li>
<p>java虚拟机规范规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可；实现时，即可是固定大小的，也可是可扩展的；当前主流的虚拟机都是可扩展的，通过-Xmx和-Xms控制； 如果堆中没有内存，并且堆也无法扩展 ，抛出OutOfMemoryError异常。</p>
</li>
<li>
<p>java堆是垃圾收集的主要区域，也称为“GC堆”;</p>
<ul>
<li>从内存回收的角度：基本采用分代收集算法，java堆分为新生代(Eden空间、From Survivor空间、To Survivor空间)和老年代；</li>
<li>从内存分配的角度：线程共享的java堆中可能划分出多个线程私有的分配缓冲区。目的是为了更好地、更快地回收内存。</li>
</ul>
</li>
</ol>
<h2> 五、方法区</h2>
<ol>
<li>存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li>所有线程共享的内存区域。</li>
<li>在HostSpot虚拟机中，使用永久代来实现方法区，这样的话垃圾收集器可以像管理Java堆一样管理这部分内存； Jdk1.7中，永久代中的字符串常量池移出。 为Native Memory实现方法区做准备。1.8称为元空间，默认的大小为MetaspaceSize 值21M.</li>
<li>方法区和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集；垃圾收集行为在方法区较少出现，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载；（回收效果差，类型卸载要求高）回收非常有必要，当方法区无法满足内存分配需求时，将抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h2> 六、运行时常量池</h2>
<ol>
<li>方法区的一部分;</li>
<li>存放的是类加载后<strong>class文件中常量池的信息</strong>;Class文件包括： 1 常量池(用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中) 2 类的基本描述信息（字段、方法、接口）</li>
</ol>
<p>运行时常量池，细节要求不高，可以根据不同的需求来实现该内存区域； Class包括其中的常量池，格式要求严格，具体到每一个字节存储的数据都必须符合才能被虚拟机认可、装载和执行；运行时常量池，不仅保存Class文件中描述的符号引用，而且也保存翻译的直接引用。</p>
<p>java语言的动态性，意味着并不要求常量一定只有编译器才能产生，也就是说不是只有提前放置在Class文件常量池中的内容才能进入方法区的运行时常量池； 在运行期也可以将新的常量放入运行时常量池，比如String的intern（）方法(调用该方法，如果常量池中包含了一个和当前对象相等的字符串则返回常量池中的字符串， 否则把改字符串放到常量池中，并返回字符串的引用.)；常量池可能报<strong>OutOfMemoryError</strong>异常。</p>
<p>常量池在运行时加载到内存中后,称为运行时常量池。</p>
<h2> 七、直接内存</h2>
<ol>
<li>NIO类，一种基于通道与缓存区的I/o方式，可以使用Native函数库直接分配堆外内存，通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用；</li>
<li>NIO的使用在某些场合避免了在java堆和Native堆中来回复制数据，提高了性能；</li>
<li>直接内存不受java堆大小的控制，但是受到本机总内存大小以及处理器寻址空间的限制；</li>
<li>也是会报<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h1> 知识补充：</h1>
<h2> 逃逸分析</h2>
<p>目的就是减少内存堆分配压力；</p>
<p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它有可能被外部方法所引用，例如，作为调用参数传递到其他地方中，称为方法逃逸。</p>
<h3> 基于逃逸分析，可以进行 同步消除、栈上分配以及标量替换的优化。</h3>
<h3> 例子：</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部
。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以做一些修改：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逃逸分析包括：</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 同步消除(锁消除)</h2>
<ol>
<li>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
</li>
<li>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
</li>
<li>
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</li>
<li>
<p>虚拟机会根据自己的代码检测结果取消一些加锁逻辑。</p>
</li>
<li>
<p>虚拟机通过检测会发现一些代码中不可能出现数据竞争，但是代码中又有加锁逻辑，为了提高性能，就消除这些锁。</p>
</li>
</ol>
<p>如果一段代码中，在堆上的所有数据都不会被其他线程访问到，那就可以把它们当成线程私有数据，自然就不需要同步加锁了。</p>
<h3> 经典例子：</h3>
<p>String 字符串拼接：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开编译后的字节码我们可以发现加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b”等效于下面的代码片。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>append方法时一个同步方法，它的方法签名是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时候，编译器就会判断出sb这个对象并不会被这段代码块以外的地方访问到，更不会被其他线程访问到，这时候的加锁就是完全没必要的，编译器就会把这里的加锁代码消除掉，
体现到java源码上就是把append方法的synchronized修饰符给去掉了。</p>
<h2> 栈上分配</h2>
<ol>
<li>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</li>
<li>栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</li>
<li>如果逃逸分析能够证明某些新建的 <strong>对象不逃逸</strong> ，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。</li>
</ol>
<h2> 标量替换</h2>
<p>定义：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<p>以上代码，经过标量替换后，就会变成：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p>标量替换为栈上分配提供了很好的基础。</p>
<p>由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。</p>
]]></content:encoded>
    </item>
    <item>
      <title>类的加载</title>
      <link>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory1ClassReload.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory1ClassReload.html</guid>
      <source url="https://merryldt.github.io/rss.xml">类的加载</source>
      <description>类的生命周期 一、过程 加载（load） 通过一个类的全限定名来获取定义此类的二进制字节流; 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构; 链接(Linking) 校验 目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<figure><figcaption>类的生命周期</figcaption></figure>
<h2> 一、过程</h2>
<h3> 加载（load）</h3>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流;</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;</li>
</ol>
<h3> 链接(Linking)</h3>
<h4> 校验</h4>
<ul>
<li>目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</li>
</ul>
<h4> 准备</h4>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用final 修饰的static，因为final 在编译的时候就会分配了,准备阶段会显示初始化；</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到JAVA堆中.</li>
</ul>
<h4> 解析</h4>
<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM 在执行完初始化之后再执行; 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>各虚拟机能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li>
<li>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_inf等。</li>
<li>对同一个符号引用进行多次解析是可能的，所以虚拟机会被第一次解析的结果进行缓存，避免解析动作重复进行。</li>
</ul>
<h3> 初始化</h3>
<ol>
<li>真正开始执行类中定义的Java程序代码(或者说是字节码)；</li>
<li>根据程序员通过程序制定的主观计划去初始化类变量和其他资源。换个角度来说，初始化阶段是执行类构造器clinit方法的过程。clinit方法不需要定义，是Javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。构造器方法中指令按语句在源文件中出现的顺序执行。clinit方法不同于类的构造器。(关联: 构造器是虚拟机视角下的init方法)</li>
<li>若该类具有父类，JVM会保证子类的clinit方法执行前，父类的clinit方法已经执行完毕。</li>
<li>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁。</li>
</ol>
<h4> 初始化时机：</h4>
<p>虚拟机规范规定了有且只有5中情况下，必须立即对类进行初始化，称为对一个类进行主动引用；</p>
<ol>
<li>遇到new、getstatic、putstatic 或invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
场景： 使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰，已在编译器把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候，</li>
<li>使用java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类；</li>
<li>当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
如果初始化的是一个接口，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候，才会初始化。比如(引用接口中定义的常量)</li>
<li>当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化，才开始执行Java程序代码。</li>
</ol>
<h4> 例子：</h4>
<figure><figcaption>类的加载过程</figcaption></figure>
<h2> 二、类加载器</h2>
<p>实现“通过一个类的全限定名来获取描述此类的二进制字节流”的动作的代码模块；</p>
<h3> 类加载器从两个角度区分:</h3>
<p>一、从虚拟机角度：</p>
<ol>
<li>启动类加载器(BootStrap ClassLoader),由C++语言实现，虚拟机自身的一部分；</li>
<li>所有其他的类加载器，由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类Java.lang.ClassLoader。</li>
</ol>
<p>二、从Java开发角度：</p>
<ol>
<li>启动类加载器；</li>
<li>扩展类加载器；</li>
<li>应用程序类加载器。</li>
</ol>
<h3> 类加载器的作用</h3>
<figure><figcaption>类加载器的作用</figcaption></figure>
<p>类加载器负责从本地文件系统或者网络中获取class文件，class 文件在文件开头有特殊的标识;
ClassLoader 只负责class文件系统的加载，至于它是否运行，则由ExcutionEngin 决定;
加载的类信息存储于一块称为方法区的内存空间。除了类的信息，方法区中还会存放运行时常量池信息，可能还会有字符串字面量和数字常量(这部分常量信息是class中常量池部分的内存映射).</p>
<figure><figcaption>类加载器的ClassLoader角色</figcaption></figure>
<ol>
<li>class file 存在于文件系统中，可以理解为设计师画在纸上的模板，而最终这个模板执行的时候是要加载进入JVM根据这个文件实例化出N个一模一样的实例。</li>
<li>class file 被加载进入JVM中，被称为 DNA 元数据模板，放在方法区；</li>
<li>在.class -&gt; JVM -&gt; 元数据模板，这就需要一个工具(类加载器 ClassLoader 扮演的角色)</li>
</ol>
<h3> 介绍三种类加载器</h3>
<h4> 启动类加载器(Bootstrap ClassLoader)</h4>
<p>工作：</p>
<ul>
<li>将存放在&lt;JAVA_HOME&gt;\lib 目录中的rt.jar，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）</li>
<li>启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>加载扩展类和应用程序类加载器，并制定为他们的父类加载器。</li>
<li>不继续自Java.lang.ClassLoader,没有父加载器。</li>
</ul>
<h4> 扩展类加载器(Extension ClassLoader)</h4>
<ul>
<li>
<p><strong>实现类</strong>:  sum.misc.Launcher$ExtClassLoader</p>
</li>
<li>
<p><strong>工作</strong>:  加载&lt;JAVA_HOME&gt;\lib\ext 目录中的或被Java.ext.dirs系统变量所指定的路径中的所有类库;开发者可以直接使用扩展类加载器。</p>
</li>
<li>
<p>如果用户创建的JAR放在次目录下,也会自动由扩展类加载器加载。</p>
</li>
</ul>
<h4> 应用程序类加载器(Application ClassLoader)</h4>
<ul>
<li>
<p><strong>实现类</strong>: sum.misc.Launcher $AppClassLoader</p>
</li>
<li>
<p><strong>工作</strong>: 加载用户类路径上所指定的类库  开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
<li>
<p><strong>由来</strong>: 是ClassLoader中的getSystemClassLoader()方法的返回值，所以也可以称之为系统类加载器。</p>
</li>
<li>
<p><strong>总结</strong>:  应用程序都是由这3中类加载器相互配合进行加载的，如果必要，可以加入自定义的类加载器。</p>
</li>
</ul>
<h3> 自定义类加载器</h3>
<h4> 为什么要自定义类加载器</h4>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<h3> 类加载器之间的关系</h3>
<h4> 双亲委派模型</h4>
<p>定义：</p>
<ul>
<li>类加载器之间的这种层次关系，称为类加载器的双亲委派模型。一种类加载器的实现方式。</li>
</ul>
<p>特点：</p>
<ul>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</li>
</ul>
<p>类加载器之间的关系：</p>
<ul>
<li>一般不会以继承的关系来实现，而都是使用组合关系来复用父加载器的代码。</li>
</ul>
<p>工作过程:</p>
<blockquote>
<blockquote>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，<br>
因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时(它的搜索范围中没有找到所需的类)，子加载器才会尝试自己去加载。</p>
</blockquote>
</blockquote>
<p>工作原理图：

好处：</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p>避免类的重复加载;</p>
<p>保护程序安全，防止核心API 被随意篡改；</p>
<blockquote>
<blockquote>
<p>比如：
类Object，它在rt.jar中，无论哪一个类加载器要加载这个类，最终都是要委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>
</blockquote>
</blockquote>
<ul>
<li>实现简单：</li>
</ul>
<blockquote>
<blockquote>
<p>Java.lang.ClassLoader的loadClass()方法中；</p>
</blockquote>
</blockquote>
<ul>
<li>实现逻辑:</li>
</ul>
<blockquote>
<blockquote>
<p>首先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。<br>
如果父类失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
</blockquote>
</blockquote>
<p>结果：</p>
<ul>
<li>解决了各个类加载的基础类的统一问题；</li>
</ul>
<h3> 局限性</h3>
<h4> 破坏双亲委派模型</h4>
<p>因为双亲委派模型的局限性，出现了三次，两个不同的加载器。</p>
<h4> 一、无法解决基础类回调用户的代；</h4>
<p>例子：</p>
<ul>
<li>比如JNDI服务，JNDI服务由启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码。</li>
</ul>
<p>问题：</p>
<ul>
<li>启动类加载器不认识JNDI接口提供者的代码；</li>
<li>JNDI服务使用线程上下文类加载器去加载所需要的的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次接口来逆向使用类加载器。</li>
</ul>
<p>解决：</p>
<ul>
<li>线程上下文类加载器。</li>
<li>线程上下文类加载器可以通过Java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
</ul>
<p>Java中所有涉及SPI的加载动作基本上都采用这种方式，如JDNI、JDBC、JCE、JAXB和JBI等。</p>
<h4> 二、用户对程序动态性的追求。</h4>
<p>说明：</p>
<ul>
<li>动态性指： 代码热替换、模块热部署等。</li>
<li></li>
</ul>
<p>解决：</p>
<ul>
<li>OSGI</li>
</ul>
<blockquote>
<blockquote>
<p>程序模块在OSGI中称为Bundle。
OSGI 实现模块化热部署的关键则是它自定义的类加载器机制的实现。<br>
每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。<br>
OSGI环境下，类加载器为复杂的网状结构。</p>
</blockquote>
</blockquote>
<ul>
<li>
<p>OSGI的请求过程：当收到类加载请求时：</p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载；</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载；</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载；</li>
<li>否则，查找当前Bundle的ClassPath,使用自己的类加载器加载;</li>
<li>否则，查找类是否在自己的Fragmentg Bundle中，如果在，则委派给Fragment Bundle的类加载器加载；</li>
<li>否则，查找Dynamic Import 列表的Bundle，委派给对应Bundle的类加载器加载;</li>
<li>否则，类查找失败。</li>
</ol>
</li>
</ul>
<h4> 三、自定义类加载器的原则：</h4>
<p>用户可以把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h3> 知识补充</h3>
<h4> 沙箱安全机制</h4>
<figure><figcaption>双亲委派机制</figcaption></figure>
<h4> 比较两个Class 对象是否为同一个类:</h4>
<p>在JVM 中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader(指ClassLoader 实例对象)必须相同。</li>
</ul>
<p>换句话说，在JVM 中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载他们的classLoader 实例对象不同，
那么这两个类对象也是不相等的。</p>
<p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM 会将这个类加载器的一个引用作为
类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两类型的类加载器是相同的。</p>
<h4> 类的主动使用和被动使用</h4>
<figure><figcaption>双亲委派机制</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>GC 体系总结</title>
      <link>https://merryldt.github.io/moyu/jvm/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">GC 体系总结</source>
      <description>背景 基础知识介绍 Mutator 应用程序,即垃圾生产者； Tlab Thread Local Allocation Buffer 的缩写，基于CAS 的独享线程(Mutator Threads) 可以优先将对象分配在Eden 中的一块内存，因为是Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个TLAB 都是一个线程独享的。 Card Table 卡表,主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为dirty,卡表的本质是用来解决跨代引用的问题。 解决的原理 Sla Service-Level Agreement(服务等级协议)的缩写；指的是系统服务提供者（Provider）对客户(Customer)的⼀个服务承诺。这是衡量⼀个⼤型分布式系统是否“健康”的常见⽅法。 可⽤性、准确性、系统容量和延迟 sla详解</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 背景</h1>
<h1> 基础知识介绍</h1>
<ol>
<li>
<p>Mutator<br>
应用程序,即垃圾生产者；</p>
</li>
<li>
<p>Tlab<br>
Thread Local Allocation Buffer 的缩写，基于CAS 的独享线程(Mutator Threads) 可以优先将对象分配在Eden 中的一块内存，因为是Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个TLAB 都是一个线程独享的。</p>
</li>
<li>
<p>Card Table<br>
卡表,主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为dirty,卡表的本质是用来解决跨代引用的问题。<br>
<a href="https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-works" target="_blank" rel="noopener noreferrer">解决的原理</a></p>
</li>
<li>
<p>Sla<br>
Service-Level Agreement(服务等级协议)的缩写；指的是系统服务提供者（Provider）对客户(Customer)的⼀个服务承诺。这是衡量⼀个⼤型分布式系统是否“健康”的常见⽅法。<br>
可⽤性、准确性、系统容量和延迟<br>
<a href="/moyu/jvm/09999_SLA.html" target="blank">sla详解</a></p>
</li>
</ol>
<h1> 路径</h1>
<figure><figcaption>Alt text</figcaption></figure>
<h2> 1. 建立知识体系</h2>
<blockquote>
<p>学习GC 的基础知识,包括:</p>
</blockquote>
<ol>
<li><a href="/moyu/jvm/02_jvm_Memory0Structure.html" target="blank">Jvm的内存结构和对象分配</a></li>
<li><a href="/moyu/jvm/03_GarbageCollectionMethod.html" target="blank">垃圾收集方法</a></li>
<li><a href="/moyu/jvm/04_GarbageCollector.html" target="blank">垃圾收集器</a></li>
<li><a href="/moyu/jvm/05_GCAnalysisTools.html" target="blank">掌握一些常用的GC问题分析工具</a></li>
</ol>
<h2> 2. 确定评价指标</h2>
<ol>
<li><a href="/moyu/jvm/06_GCEvaluationCriteria.html" target="blank">了解基本 GC 的评价方法</a></li>
<li>摸清如何设定独立系统的指标;</li>
<li>在业务场景中判断 GC 是否存在问题的手段;</li>
</ol>
<h2> 3. 场景调优实践</h2>
<ol>
<li><a href="/moyu/jvm/09_9CMS.html" target="blank">分析与解决九种 CMS 中常见 GC 问题场景</a></li>
<li><a href="/moyu/jvm/010_PracticeOne.html" target="blank">纯Java自带工具排查JVM</a></li>
</ol>
<h2> 4. 总结优化经验</h2>
]]></content:encoded>
    </item>
    <item>
      <title>垃圾收集方法</title>
      <link>https://merryldt.github.io/moyu/jvm/03_GarbageCollectionMethod.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/03_GarbageCollectionMethod.html</guid>
      <source url="https://merryldt.github.io/rss.xml">垃圾收集方法</source>
      <description>标记-清除算法: 有两个阶段，标记和清除; 工作原理： 标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象； 最基础的算法,后续的收集算法都是基于这种思路并对其不足进行改进; 缺点： 效率问题：标记和清除两个过程的效率都不高； 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</description>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 标记-清除算法:</h2>
<p>有两个阶段，标记和清除;</p>
<h3> 工作原理：</h3>
<ul>
<li>标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；</li>
<li>最基础的算法,后续的收集算法都是基于这种思路并对其不足进行改进;</li>
</ul>
<h3> 缺点：</h3>
<ol>
<li>效率问题：标记和清除两个过程的效率都不高；</li>
<li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
<h2> 复制算法:</h2>
<p>为了解决标记清除算法的效率问题;</p>
<h3> 工作原理:</h3>
<ul>
<li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块；当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li>
<li>每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li>
</ul>
<h3> 缺点:</h3>
<ul>
<li>将内存缩小为了原来的一半;</li>
<li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。现在的商业虚拟机都采用这种收集算法来回收新生代。</li>
</ul>
<h2> 标记-整理算法:</h2>
<ul>
<li>标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存；</li>
<li>年轻代采用这种算法;如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不选用复制算法；</li>
</ul>
<h2> 分代收集算法</h2>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，根据对象存活周期的不同将内存划分为几块.</p>
<h3> 工作原理:</h3>
<ul>
<li>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法;</li>
<li>在新生代中,每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集;</li>
<li>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>垃圾收集器</title>
      <link>https://merryldt.github.io/moyu/jvm/04_GarbageCollector.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/04_GarbageCollector.html</guid>
      <source url="https://merryldt.github.io/rss.xml">垃圾收集器</source>
      <category>JVM</category>
      <pubDate>Sat, 15 Jul 2023 09:14:38 GMT</pubDate>
    </item>
  </channel>
</rss>