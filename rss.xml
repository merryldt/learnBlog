<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Mon, 21 Aug 2023 12:19:51 GMT</pubDate>
    <lastBuildDate>Mon, 21 Aug 2023 12:19:51 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>算法 二叉堆</category>
    <category>redis</category>
    <item>
      <title>二叉堆</title>
      <link>https://merryldt.github.io/moyu/algorithm/datastructure/PriorityQueue.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/datastructure/PriorityQueue.html</guid>
      <source url="https://merryldt.github.io/rss.xml">二叉堆</source>
      <description>二叉堆 二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针： 两种类型: 最大堆和最小堆： 最大堆的性质是：每个节点都大于等于它的两个子节点; 最小堆的性质是：每个节点都小于等于它的子节点。 两个操作： swim(上浮) 和 sink(下沉) 在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。 最大堆的实现：</description>
      <category>算法 二叉堆</category>
      <pubDate>Fri, 04 Aug 2023 15:28:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 二叉堆</h2>
<p>二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>
<h2> 两种类型: 最大堆和最小堆：</h2>
<ul>
<li>最大堆的性质是：每个节点都大于等于它的两个子节点;</li>
<li>最小堆的性质是：每个节点都小于等于它的子节点。</li>
</ul>
<h2> 两个操作： swim(上浮) 和 sink(下沉)</h2>
<p>在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<h3> 最大堆的实现：</h3>
<p>对于最大堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<h3> 最小堆的实现：</h3>
<p>对于最小堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<h2> 基本操作代码</h2>
<h3> 节点操作</h3>

<h3> 上浮和下沉</h3>
]]></content:encoded>
    </item>
    <item>
      <title>01) Redis 概览</title>
      <link>https://merryldt.github.io/moyu/redis/01_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/01_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">01) Redis 概览</source>
      <category>redis</category>
      <pubDate>Sat, 29 Jul 2023 15:23:28 GMT</pubDate>
    </item>
    <item>
      <title>07) redis分布式锁</title>
      <link>https://merryldt.github.io/moyu/redis/07_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/07_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">07) redis分布式锁</source>
      <description>需要了解的问题 什么时候需要分布式锁？ 加、解锁的代码位置有讲究么？ 如何避免出现锁再也⽆法删除？「」 超时时间设置多少合适呢？ 如何避免锁被其他线程释放 如何实现重⼊锁？ 主从架构会带来什么安全问题？ 什么是 Redlock Redisson 分布式锁最佳实战 看⻔狗实现原理 什么时候需要分布式锁？ 为了并发问题； 重复请求；</description>
      <category>redis</category>
      <pubDate>Sat, 29 Jul 2023 15:23:28 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 需要了解的问题</h2>
<ol>
<li>什么时候需要分布式锁？</li>
<li>加、解锁的代码位置有讲究么？</li>
<li>如何避免出现锁再也⽆法删除？「」</li>
<li>超时时间设置多少合适呢？</li>
<li>如何避免锁被其他线程释放</li>
<li>如何实现重⼊锁？</li>
<li>主从架构会带来什么安全问题？</li>
<li>什么是 Redlock</li>
<li>Redisson 分布式锁最佳实战</li>
<li>看⻔狗实现原理</li>
</ol>
<h2> 什么时候需要分布式锁？</h2>
<ul>
<li>为了并发问题；</li>
<li>重复请求；</li>
</ul>
<h2> 使用分布式锁需要考虑的问题</h2>
<ol>
<li>锁加在什么地方</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>超时设置<br>
目的：为了解决锁一直被占用的问题。
<ul>
<li><strong>需要正确设置锁超时的时间</strong>；
<ol>
<li>在测试环境多次测试，压测多轮，计算出平均<strong>执行时间</strong>m。</li>
<li>锁的超时时间设置为平均执行时间的5倍左右，为程序执行期间可能发生的网络IO操作、GC、网络延迟等。留点buffer。</li>
</ol>
</li>
</ul>
</li>
<li>释放了不是自己加的锁</li>
<li>锁续期<br>
锁快过期，但是业务逻辑还没执行完成；需要给锁重新设置过期时间。<br>
Redisson 可以自动完成；</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>06) 布隆过滤器</title>
      <link>https://merryldt.github.io/moyu/redis/06_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/06_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">06) 布隆过滤器</source>
      <description>使用场景 你遇到数据量⼤，⼜需要去重的时候就可以考虑布隆过滤器 解决 Redis 缓存穿透问题（⾯试重点）； 邮件过滤，使⽤布隆过滤器实现邮件⿊名单过滤； 触发过的事件,不触发； 定义 布隆过滤器 (Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出，它是⼀种 space efficient 的概率型数据结构，⽤于判断⼀个元素是否在集合中。 当布隆过滤器说，某个数据存在时，这个数据可能不存在；当布隆过滤器说，某个数据不存在时，那么这个数据⼀定不存在。 哈希表也能⽤于判断元素是否在集合中，但是布隆过滤器只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。 布隆过滤器可以插⼊元素，但不可以删除已有元素。 其中的元素越多，false positive rate(误报率)越⼤，但是 false negative (漏报)是不可能的。</description>
      <category>redis</category>
      <pubDate>Sat, 29 Jul 2023 03:10:42 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 使用场景</h2>
<p>你遇到数据量⼤，⼜需要去重的时候就可以考虑布隆过滤器</p>
<ul>
<li>解决 Redis 缓存穿透问题（⾯试重点）；</li>
<li>邮件过滤，使⽤布隆过滤器实现邮件⿊名单过滤；</li>
<li>触发过的事件,不触发；</li>
</ul>
<h2> 定义</h2>
<ul>
<li>布隆过滤器 (Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出，它是⼀种 space efficient 的概率型数据结构，⽤于判断⼀个元素是否在集合中。</li>
<li>当布隆过滤器说，某个数据存在时，这个数据可能不存在；当布隆过滤器说，某个数据不存在时，那么这个数据⼀定不存在。</li>
<li>哈希表也能⽤于判断元素是否在集合中，但是布隆过滤器只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。</li>
<li>布隆过滤器可以插⼊元素，但不可以删除已有元素。</li>
<li>其中的元素越多，false positive rate(误报率)越⼤，但是 false negative (漏报)是不可能的。</li>
</ul>
<h2> 原理</h2>
<p>BloomFilter 的算法</p>
<ol>
<li>首先分配一块内存空间做bit 数组，数组的bit位初始值全部设为0.</li>
<li>加入元素时，采用k个相互独立的Hash 函数计算，然后将元素Hash 映射的K个位置全部设置为1.</li>
<li>检测key是否存在，仍然用这k个Hash函数计算出k个位置，如果位置全部为1，则表明key存在，否则不存在。</li>
</ol>
<h3> 误判率是为甚么？</h3>
<p><strong>哈希函数会出现碰撞，所以布隆过滤器会存在误判</strong></p>
<ul>
<li>误判率是指： BloomFilter判断某个key存在，但它实际不存在的概率，因为它存的是key的Hash值，而非key的值。</li>
<li>所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同</li>
</ul>
<p><em>对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，⽽不会是 0。布隆过滤器判断存在不⼀定真的存在。</em></p>
<h3> 为什么不允许删除元素呢？</h3>
<ul>
<li>删除意味着需要将对应的 k 个 bits 位置设置为 0，其中有可能是其他元素对应的位。</li>
<li>因此 remove 会引⼊ false negative，这是绝对不被允许的</li>
</ul>
<h2> 优劣</h2>
<h3> 优点：</h3>
<ol>
<li>支持海量数据场景下高效判断元素是否存在</li>
<li>存储空间小，并且节省空间，不存储数据本身，仅存储hash结果取模运算后的位标记</li>
</ol>
<h3> 缺点：</h3>
<ol>
<li>不能删除；</li>
<li>存在误判；</li>
<li>容量越大，hash碰撞的概率变大</li>
</ol>
<h2> 实现方式：</h2>
<h3> Google开源的Guava自带布隆过滤器</h3>
<p>单机</p>
<h3> redis(redisson)</h3>
<p>redis 需要安装插件才可以。阿里云的redis 应该是支持的。
分布式 redisson</p>
]]></content:encoded>
    </item>
    <item>
      <title>05) Redis⾼效的数据结构</title>
      <link>https://merryldt.github.io/moyu/redis/05_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/05_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">05) Redis⾼效的数据结构</source>
      <description>常用的主要数据类型有五种 字符串/REDIS_STRING：适用于 缓存、计数、共享Session、IP统计、分布式锁等。 列表/REDIS_LIST： 链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表）。 哈希表/REDIS_HASH： 购物车信息、用户信息、Hash类型的(key, field, value)存储对象等。 集合/REDIS_SET：无序的唯一的键值结构： 好友、关注、粉丝、感兴趣的人集合等。 有序集合/REDIS_ZSET：访问排行榜、点赞排行、粉丝数排行等。</description>
      <category>redis</category>
      <pubDate>Fri, 28 Jul 2023 15:56:31 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 常用的主要数据类型有五种</h2>
<ol>
<li>字符串/REDIS_STRING：适用于 缓存、计数、共享Session、IP统计、分布式锁等。</li>
<li>列表/REDIS_LIST： 链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表）。</li>
<li>哈希表/REDIS_HASH： 购物车信息、用户信息、Hash类型的(key, field, value)存储对象等。</li>
<li>集合/REDIS_SET：无序的唯一的键值结构： 好友、关注、粉丝、感兴趣的人集合等。</li>
<li>有序集合/REDIS_ZSET：访问排行榜、点赞排行、粉丝数排行等。</li>
</ol>
<h2> SDS 简单动态字符串</h2>
<p>Redis使用简单动态字符串（simple dynamic string，SDS）来表示字符串，Redis中字符串类型包含的数据结构有：整数（R_INT） 、 字符串（R_RAW）。<br>
我们以字符串为例子，常规的字符串，如 "Brand"，如果要获取他的长度，需要从头开始遍历，直至遇到 \0 空字符代表结尾,如 C字符串。</p>
<blockquote>
<blockquote>
<p>redis 是用c 语言写的，为啥不用c语言的字符串呢？</p>
</blockquote>
</blockquote>
<h3> SDS与c语言字符串的区别：</h3>
<ol>
<li>
<p>获取字符串长度时间复杂度不同 。
C字符串不记录自身长度，获取C字符串长度时必须遍历整个字符串计数得到，复杂度是O(N)<br>
SDS字符串自身记录维护len长度属性，获得SDS字符串长度的复杂度是O(1)</p>
</li>
<li>
<p>避免缓冲区溢出。
C字符串不记录长度，由于两个C字符串在内存存储上紧邻，在执行字符串拼接strcat时，如果不提前分配足够空间，很可能发生修改s1的数据溢出到s2所在的空间中（缓冲区溢出）。<br>
SDS杜绝了缓冲区溢出问题，它记录了长度，当修改SDS字符串之前，API都会检查SDS的空间是否满足修改的要求，不满足API会自动进行空间扩展。</p>
</li>
<li>
<p>空间预分配，减少修改时的内存重分配次数
SDS 被修改后，程序不仅会为 SDS 分配所需要的空间，还会分配额外的未使用空间。这样，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>redis的SDS中内置一个sdscat函数，也是用于字符串的拼接。</p>
<p><strong>具体的分配策略有两种</strong>:</p>
<ul>
<li>如修改后长度len小于1MB，就分配和len属性相同大小的未使用空间：free=len。比如：修改后字符串长度为 10bit.那么程序也会分配10bit的未使用空间，SDS的buf数组的总长度 =  10(字符串) + 10(未使用空间)+1（空字符串）= 21 bit</li>
<li>如修改后长度len大于等于1MB，就分配1M的未使用空间：free=1MB。比如：修改后字符串长度为 10M.那么程序也会分配1M的未使用空间,SDS的buf数组的总长度 =  10 M (字符串) + 1(未使用空间)= 11 M</li>
</ul>
<p><strong>第一次执行sdscat函数</strong></p>
<ol>
<li>sdscat(s,"jidfkqeqwe")</li>
<li>假如分配了 15 + 15 + 1 = 31 bit</li>
</ol>
<p><strong>第二次执行sdscat函数</strong></p>
<ol>
<li>sdscat(s,"jdfwe")</li>
<li>发现未使用的15bit， 大于“jdfwe”的长度，好了，不用再执行内存分配了。</li>
</ol>
<p>上述机制，避免了redis字符串增长情况下频繁申请空间的情况。每次字符串增长之前，sds会先检查空间是否足够，如果足够则直接使用预分配的空间，否则按照上述机制申请使用空间。该机制，使得字符串增长n次，需要申请空间的次数，从必定为n次的情况，降为最多n次的情况。</p>
</li>
<li>
<p>惰性空间释放
懒惰空间释放用于优化sds字符串缩短的操作，实现方式为：当需要缩短sds的长度时，并不立即释放空间，而是使用free来保存剩余可用长度，并等待将来使用。当有剩余空间，而有有增长字符串操作时，则又会调用空间预分配机制。</p>
<p>当redis内存空间不足时，会自动释放sds中未使用的空间，因此也不需要担心内存泄漏问题。</p>
</li>
<li>
<p>二进制安全</p>
<p>C语言的字符必须符合某种编码，例如ascii，且字符串除了末尾之外，不能有空格，否则会被当作是另一个字符串。这些限制使得c语言的字符串只能保存不含空格的文本，不能保存图片、视频等二进制数据，也不能保存包含空格的文本。<br>
而保存图片、大段文本等内容，也是redis的常用场景。因此，redis也对此进行优化。因此，sds是二进制安全的，写入的是什么内容，返回的也是什么内容，并没有限制。<br>
在 C 中遇到 '\0' 则表示字符串的结束，但SDS不是，它是以len长度标识结尾。</p>
</li>
</ol>
<h2> Redis缓冲区溢出及解决方案</h2>
]]></content:encoded>
    </item>
  </channel>
</rss>