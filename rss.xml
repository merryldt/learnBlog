<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Thu, 27 Jul 2023 17:45:36 GMT</pubDate>
    <lastBuildDate>Thu, 27 Jul 2023 17:45:36 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>redis</category>
    <category>算法 链表</category>
    <category>算法</category>
    <category>JVM</category>
    <item>
      <title>缓存击穿、穿透、雪崩</title>
      <link>https://merryldt.github.io/moyu/redis/03_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/03_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">缓存击穿、穿透、雪崩</source>
      <description>缓存击穿（失效） 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 或者过期时间再加⼀个随机值。 设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }</description>
      <category>redis</category>
      <pubDate>Thu, 27 Jul 2023 17:43:37 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 缓存击穿（失效）</h2>
<ul>
<li>背景: 缓存被删除或者失效</li>
<li>现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。</li>
<li>关键字：单⼀热点数据、⾼并发、数据失效</li>
<li>描述：
⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。</li>
</ul>
<h3> 解决方案：</h3>
<ol>
<li>
<p>过期时间 + 随机值</p>
<p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。
或者过期时间再加⼀个随机值。<br>
设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒</p>
</li>
<li>
<p>预热<br>
分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。</p>
</li>
<li>
<p>加锁</p>
<ul>
<li>当发现缓存失效的时候，不是⽴即从数据库加载数据。</li>
<li>⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。</li>
<li>这样只让⼀个请求去数据库读取数据</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 缓存穿透</h2>
<p>缓存穿透：意味着有特殊请求在查询⼀个不存在的数据，即不数据存在 Redis 也不存在于数据库。
导致每次请求都会穿透到数据库，缓存成了摆设，对数据库产⽣很⼤压⼒从⽽影响正常服务。</p>
<figure><figcaption>Alt text</figcaption></figure>
<h3> 解决⽅案</h3>
<ul>
<li>缓存空值：当请求的数据不存在 Redis 也不存在数据库的时候，设置⼀个缺省值（⽐如：None）。当后续再次进⾏查询则直接返回空值或者缺省值。</li>
<li>布隆过滤器：在数据写⼊数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据⼀定没有在数据库中保存，就不要去数据库查询了
<strong>布隆过滤器</strong>
BloomFilter 要缓存全量的 key，这就要求全量的 key 数量不⼤，10 亿 条数据以内最佳，因为 10 亿 条数据⼤概要占⽤ 1.2GB 的内存。</li>
</ul>
<p>说下布隆过滤器的原理吧</p>
<p>BloomFilter 的算法是，⾸先分配⼀块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。
加⼊元素时，采⽤ k 个相互独⽴的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为1。</p>
<p>检测 key 是否存在，仍然⽤这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。</p>
<figure><figcaption>Alt text</figcaption></figure>
<p>哈希函数会出现碰撞，所以布隆过滤器会存在误判。
这⾥的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，⽽⾮ key 的值。</p>
<p>所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。
对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，⽽不会是 0。布隆过滤器判断存在不⼀定真的存在。</p>
<h2> 缓存雪崩</h2>
<p>缓存雪崩指的是⼤量的请求⽆法在 Redis 缓存系统中处理，请求全部打到数据库，导致数据库压⼒激增，甚⾄宕
机。
出现该原因主要有两种：</p>
<ul>
<li>⼤量热点数据同时过期，导致⼤量请求需要查询数据库并写到缓存；</li>
<li>Redis 故障宕机，缓存系统异常。</li>
</ul>
<h3> 原因：</h3>
<p><strong>缓存⼤量数据同时过期</strong></p>
<p>数据保存在缓存系统并设置了过期时间，但是由于在同时⼀刻，⼤量数据同时过期。<br>
系统就把请求全部打到数据库获取数据，并发量⼤的话就会导致数据库压⼒激增。<br>
缓存雪崩是发⽣在⼤量数据同时失效的场景，⽽缓存击穿（失效）是在某个热点数据失效的场景，这是他们最⼤的区别。</p>
<figure><figcaption>Alt text</figcaption></figure>
<p>解决⽅案</p>
<ol>
<li>
<p>过期时间添加随机值
要避免给⼤量的数据设置⼀样的过期时间，过期时间 = baes 时间+ 随机时间（较⼩的随机数，⽐如随机增加 1~5分钟）。<br>
这样⼀来，就不会导致同⼀时刻热点数据全部失效，同时过期时间差别也不会太⼤，既保证了相近时间失效，⼜能满⾜业务需求。</p>
</li>
<li>
<p>接⼝限流
当访问的不是核⼼数据的时候，在查询的⽅法上加上接⼝限流保护。⽐如设置 10000 req/s。<br>
如果访问的是核⼼数据接⼝，缓存不存在允许从数据库中查询并设置到缓存中。<br>
这样的话，只有部分请求会发送到数据库，减少了压⼒。<br>
限流，就是指，我们在业务系统的请求⼊⼝前端控制每秒进⼊系统的请求数，避免过多的请求被发送到数据库。</p>
<figure><figcaption>接⼝限流</figcaption></figure>
</li>
</ol>
<p><strong>Redis 故障宕机</strong></p>
<p>⼀个 Redis 实例能⽀撑 10 万的 QPS，⽽⼀个数据库实例只有 1000 QPS。<br>
⼀旦 Redis 宕机，会导致⼤量请求打到数据库，从⽽发⽣缓存雪崩。</p>
<h3> 解决方案：</h3>
<p>对于缓存系统故障导致的缓存雪崩的解决⽅案有两种：</p>
<ul>
<li>服务熔断和接⼝限流；</li>
<li>构建⾼可⽤缓存集群系统。</li>
</ul>
<p><strong>服务熔断和限流</strong></p>
<p>在业务系统中，针对⾼并发的使⽤服务熔断来有损提供服务从⽽保证系统的可⽤性。
服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防⽌所有流量打到数据库导致宕机。
服务熔断和限流属于在发⽣了缓存雪崩，如何降低雪崩对数据库造成的影响的⽅案。</p>
<p><strong>构建⾼可⽤的缓存集群</strong></p>
<p>所以，缓存系统⼀定要构建⼀套 Redis ⾼可⽤集群，⽐如 《Redis 哨兵集群》或者 《Redis Cluster 集群》，如果Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机⽽导致的缓存雪崩问题。</p>
<h2> 总结</h2>
<ul>
<li>缓存穿透指的是数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</li>
<li>缓存击穿（失效）指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被
击穿了，请求直奔数据库。</li>
<li>缓存雪崩指的是⼤量的热点数据⽆法在 Redis 缓存中处理（⼤⾯积热点数据缓存失效、Redis 宕机），流量全部打到数据库，导致数据库极⼤压⼒。</li>
</ul>
<h2> 思考</h2>
]]></content:encoded>
    </item>
    <item>
      <title>讲讲 Redis 缓存更新一致性</title>
      <link>https://merryldt.github.io/moyu/redis/02_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/02_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">讲讲 Redis 缓存更新一致性</source>
      <description>自己使用的场景 通常我们是先从缓存中读取，如果有，返回；如果没有，则从数据库中读取，返回写入缓存，并返回。 代码如下： public String getUserName(Integer userId){ // 因为key 通常会加一些前缀，作为指定作用的key; 这里id实际是userId. String userIdkey = &amp;quot;redis:userId:&amp;quot;+userId; String userName = redis.get(userIdkey); if(StringUtils.isNotEmppty()){ return userName; } userName = userMapper.getOne(1); redis.set(userIdkey,userName); return userName; }</description>
      <category>redis</category>
      <pubDate>Thu, 27 Jul 2023 14:40:18 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 自己使用的场景</h2>
<p>通常我们是先从缓存中读取，如果有，返回；如果没有，则从数据库中读取，返回写入缓存，并返回。<br>
代码如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写到这里是不是发现还会有一个问题？就是如果 userName 在其他地方更新了呢？ 所以一定还有一段：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想一想，如果这两个操作是两个线程操作？并且交叉操作呢？会发生什么问题？</p>
<h2> 在使用redis作为缓存时,写操作</h2>
<p>当执行写操作后，因为需要保证从缓存读取到的数据与数据库中的数据是一致的，这就需要对缓存进行更新。</p>
<h2> 旧key 是删除还是更新？缓存和数据库的更新顺序？</h2>
<ol>
<li>想想，自己目前使用的方式是什么？</li>
<li>想想，还有什么方式？以及对比自己使用的，优劣对比？</li>
</ol>
<h2> 四大策略</h2>
<h3> 1. 先删除缓存，再更新数据库</h3>
<ul>
<li>并发问题:</li>
</ul>
<blockquote>
<blockquote>
<p>写： 线程张三<br>
读： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"></td>
<td style="text-align:right">缓存失效</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">从数据库读取数据为v1</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">更新数据库为v2</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"></td>
<td style="text-align:right">将v1写入缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h3> 2. 先更新数据库，再删除缓存</h3>
<ol>
<li>若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。</li>
<li>并发问题:</li>
</ol>
<blockquote>
<blockquote>
<p>读： 线程张三<br>
写： 线程李四</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">缓存失效</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">从数据库读取数据为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库</td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">删除缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">写入缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h3> 3. 先更新缓存，再更新数据库</h3>
<ol>
<li>缓存更新成功，数据库有更新失败的风险；导致最新的数据未持久化，风险很高。</li>
<li>并发问题。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">更新缓存为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v1</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新缓存为v2</td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">更新数据库为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right">v2</td>
</tr>
</tbody>
</table>
<h3> 4. 先更新数据库，再更新缓存</h3>
<ol>
<li>同删除缓存策略一样，若数据库更新成功缓存更新失败则会造成数据不一致问题。</li>
<li>并发问题。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:right">v0</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">更新缓存为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新缓存为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v0</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"></td>
<td style="text-align:right">更新数据库为v2</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">更新数据库为v1</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
</tbody>
</table>
<h2> 对于旧key,目前已知的两种策略</h2>
<ol>
<li>删除失效缓存: 读取时会因为未命中缓存而从数据库中读取新的数据并更新到缓存中</li>
<li>更新缓存: 直接将新的数据写入缓存覆盖过期数据</li>
</ol>
<h2> 更新缓存和数据库的前后顺序，也有两种</h2>
<ol>
<li>先数据库后缓存</li>
<li>先缓存后数据库</li>
</ol>
<h2> 总结,设计需要考虑的问题</h2>
<p>根据实际场景选择一款就行，折中；</p>
<h3> 对系统吞吐量的影响：</h3>
<p>比如更新缓存策略产生的数据库负载小于删除缓存策略的负载</p>
<h3> 并发安全性：</h3>
<p>并发读写时某些异常操作顺序可能造成数据不一致，如缓存中长期保存过时数据</p>
<h3> 更新失败的影响：</h3>
<p>若某个操作失败，如何对业务影响降到最小</p>
<h3> 检测和修复故障的难度:</h3>
<p>操作失败导致的错误会在日志留下详细的记录容易检测和修复。并发问题导致的数据错误没有明显的痕迹难以发现，且在流量高峰期更容易产生并发错误产生的业务风险较大。</p>
<h2> 如何解决以上并发导致的问题？</h2>
<h3> 1. 使用 CAS</h3>
<p>CAS (Check-And-Set 或 Compare-And-Swap)是一种常见的保证并发安全的手段。CAS 当且仅当客户端最后一次取值后该 key 没有被其他客户端修改的情况下，才允许当前客户端将新值写入。</p>
<ul>
<li>CAS 是一种乐观锁</li>
</ul>
<p>假如缓存初始值是v0,更新缓存的时候，必须要校验值等于v0，才去更新，否则放弃。</p>
<ul>
<li>目前已知的redis 提供CAS命令的中间件和redis官方支持的。</li>
</ul>
<blockquote>
<blockquote>
<ol>
<li>比如阿里的 Tair 以及腾讯的 Tendis。</li>
<li>Redis 官方提供了 Watch + 事务的方法来支持 CAS, 或者使用 redis 中 lua 脚本原子性执行的特点来实现 CAS。(比较复杂)</li>
</ol>
</blockquote>
</blockquote>
<h3> 2. 使用分布式锁</h3>
<ul>
<li>分布式锁是一种悲观锁</li>
</ul>
<blockquote>
<blockquote>
<ol>
<li>线程张三 拿到锁</li>
<li>线程张三操作</li>
<li>线程张三 释放锁</li>
<li>线程李四 拿到锁</li>
<li>线程李四操作</li>
<li>线程李四 释放锁</li>
</ol>
</blockquote>
</blockquote>
<p>可以解决并发问题，只是成本可能略高。</p>
<h3> 3. 延时双删</h3>
<ul>
<li>问题是: 读线程的写入缓存操作，发生于写线程的数据库数据更新之后。会发生缓存和数据库数据不一致的问题。</li>
<li>解决： 因为是读线程最后写入缓存，此时再清除缓存是不是就可以解决这个问题？<br>
延时双删就是写线程等待一段时间“确保”读线程都结束后再次删除缓存，以此清除可能的错误缓存数据。</li>
<li>需要注意的是: 因为无法确保读线程何时结束,所以仍有存在数据不一致的可能。</li>
</ul>
<p>但是延时双删实现成本很低而且极大的减少了并发问题出现的概率，不失为一种简单实用的手段。</p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">顺序</th>
<th style="text-align:center">线程:张三</th>
<th style="text-align:right">线程:李四</th>
<th style="text-align:right">数据库</th>
<th style="text-align:right">缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"></td>
<td style="text-align:right">缓存失效</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"></td>
<td style="text-align:right">从数据库读取数据为v1</td>
<td style="text-align:right">v1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">更新数据库为v2</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"></td>
<td style="text-align:right">将v1写入缓存</td>
<td style="text-align:right">v2</td>
<td style="text-align:right">v1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center">延时一段时间,删除缓存</td>
<td style="text-align:right"></td>
<td style="text-align:right">v2</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h3> 4. 异步更新</h3>
<p>阿里开源了 MySQL 数据库binlog的增量订阅和消费组件 - canal。canal 模拟从库获得主库的 binlog 更新，然后将更新数据写入 MQ 或直接进行消费。<br>
我们可以让API服务器只负责写入数据库，另一个线程订阅数据库 binlog 增量进行缓存更新。<br>
因为 binlog 是有序的，因此可以避免两个写线程竞争。但我们仍然需要解决读写线程竞争的问题:</p>
<figure><figcaption>Alt text</figcaption></figure>
<h2> 实际场景中，你采用的是何种方式？</h2>
<h2> 这里可以延伸的问题？</h2>
<ol>
<li>如果使用的分布式锁，用的哪种？了解其原理不？</li>
<li>如果采用先删除缓存/缓存失效？导致大量请求到数据库？</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>双指针技巧</title>
      <link>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/basic/01_0.html</guid>
      <source url="https://merryldt.github.io/rss.xml">双指针技巧</source>
      <description>七道题: 合并两个有序链表 链表的分解 合并 k 个有序链表 寻找单链表的倒数第 k 个节点 寻找单链表的中点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 合并两个有序链表 力扣</description>
      <category>算法 链表</category>
      <pubDate>Tue, 25 Jul 2023 00:32:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 七道题:</h2>
<ol>
<li>合并两个有序链表</li>
<li>链表的分解</li>
<li>合并 k 个有序链表</li>
<li>寻找单链表的倒数第 k 个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
<h3> 合并两个有序链表</h3>
<p>
<a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener noreferrer">力扣</a></p>

]]></content:encoded>
    </item>
    <item>
      <title>算法入门开始</title>
      <link>https://merryldt.github.io/moyu/algorithm/01_total.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/01_total.html</guid>
      <source url="https://merryldt.github.io/rss.xml">算法入门开始</source>
      <description>::: code-tabs#shell @tab pnpm pnpm create vuepress-theme-hope [dir] @tab yarn yarn create vuepress-theme-hope [dir] @tab npm npm init vuepress-theme-hope [dir] :::</description>
      <category>算法</category>
      <pubDate>Sat, 22 Jul 2023 11:47:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>::: code-tabs#shell</p>
<p>@tab pnpm</p>
<p>pnpm create vuepress-theme-hope [dir]
@tab yarn</p>
<p>yarn create vuepress-theme-hope [dir]
@tab npm</p>
<p>npm init vuepress-theme-hope [dir]
:::</p>
]]></content:encoded>
    </item>
    <item>
      <title>纯Java自带工具排查JVM</title>
      <link>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/010_PracticeOne.html</guid>
      <source url="https://merryldt.github.io/rss.xml">纯Java自带工具排查JVM</source>
      <description>1. 获取java 进程的pid ps -ef | grep java jps 2. 使用jmap jmap -heap pid 获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。 root@iZuf64eg43tiam73abxiweZ:~# /usr/local/btjdk/jdk8/bin/jmap -heap 1028098 Attaching to process ID 1028098, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.71-b00 #1. using parallel threads in the new generation. using thread-local object allocation. Concurrent Mark-Sweep GC # 2. Heap Configuration: MinHeapFreeRatio = 40 MaxHeapFreeRatio = 70 MaxHeapSize = 4294967296 (4096.0MB) NewSize = 348913664 (332.75MB) MaxNewSize = 348913664 (332.75MB) OldSize = 3946053632 (3763.25MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB) #3. Heap Usage: New Generation (Eden + 1 Survivor Space): capacity = 314048512 (299.5MB) used = 166875944 (159.14530181884766MB) free = 147172568 (140.35469818115234MB) 53.136995598947465% used Eden Space: capacity = 279183360 (266.25MB) used = 132010792 (125.89530181884766MB) free = 147172568 (140.35469818115234MB) 47.28462040144513% used From Space: capacity = 34865152 (33.25MB) used = 34865152 (33.25MB) free = 0 (0.0MB) 100.0% used To Space: capacity = 34865152 (33.25MB) used = 0 (0.0MB) free = 34865152 (33.25MB) 0.0% used concurrent mark-sweep generation: capacity = 3946053632 (3763.25MB) used = 1832479232 (1747.58837890625MB) free = 2113574400 (2015.66162109375MB) 46.43827486630572% used 38355 interned Strings occupying 4029456 bytes.</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1. 获取java 进程的pid</h1>
<ol>
<li>ps -ef | grep java
</li>
<li>jps
</li>
</ol>
<h1> 2. 使用jmap</h1>
<h2> jmap -heap pid</h2>
<p>获取整个堆空间的详细信息。包括GC的使用、堆的配置信息，以及内存的使用信息等。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>第一部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用的是serial收集器（也叫串行收集器）即 Mark Sweep Compact GC。</li>
</ul>
<ol start="2">
<li>第二部分：</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>MinHeapFreeRatio和MaxHeapFreeRatio: 设置堆的最小最大空闲比例。</li>
<li>MaxHeapSize: 堆的最大大小。</li>
<li>NewSize: 新生代的默认值。</li>
<li>MaxNewSize: 新生代的最大值</li>
<li>OldSize: 老年代的默认值。</li>
<li>NewRatio: 新生代和老年代的大小比例，即老年代:新生代=2:1,默认为2.</li>
<li>SurvivorRatio: 新生代中的eden区与survivor的比例=8:1.</li>
<li>MetaspaceSize: 1.8 开始叫元空间大小,使用本地内存的</li>
<li>CompressedClassSpaceSize: 类指针压缩空间大小, 默认为1G</li>
<li>MaxMetaspaceSize: 元空间的最大值。一般设置和MetaspaceSize一样大小。</li>
<li>G1HeapRegionSize: G1区块的大小, 取值为1M至32M. 其取值是要根据最小Heap大小划分出2048个区块</li>
</ul>
<ol start="3">
<li>第三部分:</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>新生代: 指eden加上一个survivor空间。容量有300M这样，使用了159M，还有140M空闲. 接近53%的使用率。（根据分代的思想，新生代都是一个eden 加上2个survivor）</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>单独的eden区: 大小为266M,使用125M,空闲140, 使用率47%</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>一个surivor区，是在使用着的</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另一个survivor的使用情况。此时没有被使用。和From Space 大小一致；</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>老年代： 总的大小是3763M，使用1747M,空闲2015M,使用率是46%。</li>
</ul>
<ol start="4">
<li>总结：
为java 进程分配了 4096M 的内存；
Eden Space + From Space + To Space + concurrent mark-sweep generation = 4096</li>
</ol>
<h1> 3. 使用jstat</h1>
<p>jstat -gc -t 1028098  60000 20</p>
<p>
从图中红框标记的的两条数据分析：</p>
<ul>
<li>一分钟采集1次gc 的数据，第一条和最后一条就是 19分钟。</li>
</ul>
<ol>
<li>GCT 总的gc 时间是 891.076秒</li>
<li>GCT 总的gc 时间是  895.115 秒
系统的吞吐量 = 1- （895.115-891.076）/ 19 *60   = 1- 0.0035  = 0.9965 = 99.65%</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Jvm的内存结构和对象分配</title>
      <link>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</link>
      <guid>https://merryldt.github.io/moyu/jvm/02_Jvm_Memory0Structure.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Jvm的内存结构和对象分配</source>
      <description>图示 内存区域划分 JVM 内存区域 内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。 JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。 不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 线程 每个JVM只有一个Runtime实例。称为运行时环境。 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。） 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</description>
      <category>JVM</category>
      <pubDate>Wed, 19 Jul 2023 04:48:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 图示</h1>
<figure><figcaption>内存区域划分</figcaption></figure>
<h1> JVM 内存区域</h1>
<ol>
<li>内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。</li>
<li>JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略,保证了JVM 的高效稳定运行。</li>
<li>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li>
</ol>
<h2> 线程</h2>
<ol>
<li>每个JVM只有一个Runtime实例。称为运行时环境。</li>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li>
<li>在HopsoptJVM中，每个线程都与操作系统的本地线程直接映射。（当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。）</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li>
</ol>
<h3> 守护线程、普通线程</h3>
<h2> 一、程序计算器</h2>
<p>极小的内存空间,线程私有的,当前线程的行号指示器，程序的分支、循环、跳转、异常处理、线程恢复等基本功能都需要依赖程序计算器；比如(多线程切换)。<br>
线程执行的是:</p>
<ol>
<li>Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>Native方法，计数器值为空；</li>
</ol>
<p>值得注意的是它是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域</p>
<h2> 二、java虚拟机栈</h2>
<ol>
<li>
<p>虚拟机栈描述的是java方法执行的内存模型：线程私有的，生命周期与线程相同。</p>
</li>
<li>
<p>每个方法在执行的同时都会创建一个栈帧用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息；方法的调用直至执行完成的过程，对应着栈帧在虚拟机栈中<strong>入栈到出栈</strong>的过程。</p>
</li>
<li>
<p>虚拟机栈主要的部分是<strong>局部变量表</strong> ，其存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址);</p>
</li>
<li>
<p><u>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小</u>。</p>
</li>
<li>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出<strong>OutOfMemoryErro</strong>异常。</p>
</li>
</ol>
<h2> 三、本地方法栈</h2>
<p>与虚拟机栈作用类似，本地方法栈是虚拟机栈使用到的Native方法服务；SunHotSpot虚拟机把本地方法栈和虚拟机栈结合; 本地方法栈也会报虚拟机栈的两种异常。</p>
<h2> 四、java堆</h2>
<ol>
<li>
<p>java虚拟机管理的最大的一块内存；</p>
</li>
<li>
<p>所有线程共享的内存区域；</p>
</li>
<li>
<p>目的：存放对象实例，几乎所有的对象实例都在这里分配内存；（所有的对象实例以及数组都要在堆上分配）特别注意的是： 随着JIT编译器的发展与逃逸分析技术的成熟，<strong>栈上分配、标量替换优化技术</strong>带来了变化。不是所有对象都在堆上分配内存了。</p>
</li>
<li>
<p>java虚拟机规范规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可；实现时，即可是固定大小的，也可是可扩展的；当前主流的虚拟机都是可扩展的，通过-Xmx和-Xms控制； 如果堆中没有内存，并且堆也无法扩展 ，抛出OutOfMemoryError异常。</p>
</li>
<li>
<p>java堆是垃圾收集的主要区域，也称为“GC堆”;</p>
<ul>
<li>从内存回收的角度：基本采用分代收集算法，java堆分为新生代(Eden空间、From Survivor空间、To Survivor空间)和老年代；</li>
<li>从内存分配的角度：线程共享的java堆中可能划分出多个线程私有的分配缓冲区。目的是为了更好地、更快地回收内存。</li>
</ul>
</li>
</ol>
<h2> 五、方法区</h2>
<ol>
<li>存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li>所有线程共享的内存区域。</li>
<li>在HostSpot虚拟机中，使用永久代来实现方法区，这样的话垃圾收集器可以像管理Java堆一样管理这部分内存； Jdk1.7中，永久代中的字符串常量池移出。 为Native Memory实现方法区做准备。1.8称为元空间，默认的大小为MetaspaceSize 值21M.</li>
<li>方法区和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集；垃圾收集行为在方法区较少出现，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载；（回收效果差，类型卸载要求高）回收非常有必要，当方法区无法满足内存分配需求时，将抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h2> 六、运行时常量池</h2>
<ol>
<li>方法区的一部分;</li>
<li>存放的是类加载后<strong>class文件中常量池的信息</strong>;Class文件包括： 1 常量池(用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中) 2 类的基本描述信息（字段、方法、接口）</li>
</ol>
<p>运行时常量池，细节要求不高，可以根据不同的需求来实现该内存区域； Class包括其中的常量池，格式要求严格，具体到每一个字节存储的数据都必须符合才能被虚拟机认可、装载和执行；运行时常量池，不仅保存Class文件中描述的符号引用，而且也保存翻译的直接引用。</p>
<p>java语言的动态性，意味着并不要求常量一定只有编译器才能产生，也就是说不是只有提前放置在Class文件常量池中的内容才能进入方法区的运行时常量池； 在运行期也可以将新的常量放入运行时常量池，比如String的intern（）方法(调用该方法，如果常量池中包含了一个和当前对象相等的字符串则返回常量池中的字符串， 否则把改字符串放到常量池中，并返回字符串的引用.)；常量池可能报<strong>OutOfMemoryError</strong>异常。</p>
<p>常量池在运行时加载到内存中后,称为运行时常量池。</p>
<h2> 七、直接内存</h2>
<ol>
<li>NIO类，一种基于通道与缓存区的I/o方式，可以使用Native函数库直接分配堆外内存，通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用；</li>
<li>NIO的使用在某些场合避免了在java堆和Native堆中来回复制数据，提高了性能；</li>
<li>直接内存不受java堆大小的控制，但是受到本机总内存大小以及处理器寻址空间的限制；</li>
<li>也是会报<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<h1> 知识补充：</h1>
<h2> 逃逸分析</h2>
<p>目的就是减少内存堆分配压力；</p>
<p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它有可能被外部方法所引用，例如，作为调用参数传递到其他地方中，称为方法逃逸。</p>
<h3> 基于逃逸分析，可以进行 同步消除、栈上分配以及标量替换的优化。</h3>
<h3> 例子：</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部
。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以做一些修改：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逃逸分析包括：</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 同步消除(锁消除)</h2>
<ol>
<li>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
</li>
<li>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
</li>
<li>
<p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</li>
<li>
<p>虚拟机会根据自己的代码检测结果取消一些加锁逻辑。</p>
</li>
<li>
<p>虚拟机通过检测会发现一些代码中不可能出现数据竞争，但是代码中又有加锁逻辑，为了提高性能，就消除这些锁。</p>
</li>
</ol>
<p>如果一段代码中，在堆上的所有数据都不会被其他线程访问到，那就可以把它们当成线程私有数据，自然就不需要同步加锁了。</p>
<h3> 经典例子：</h3>
<p>String 字符串拼接：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开编译后的字节码我们可以发现加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b”等效于下面的代码片。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>append方法时一个同步方法，它的方法签名是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时候，编译器就会判断出sb这个对象并不会被这段代码块以外的地方访问到，更不会被其他线程访问到，这时候的加锁就是完全没必要的，编译器就会把这里的加锁代码消除掉，
体现到java源码上就是把append方法的synchronized修饰符给去掉了。</p>
<h2> 栈上分配</h2>
<ol>
<li>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</li>
<li>栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</li>
<li>如果逃逸分析能够证明某些新建的 <strong>对象不逃逸</strong> ，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。</li>
</ol>
<h2> 标量替换</h2>
<p>定义：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p>
<p>以上代码，经过标量替换后，就会变成：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p>标量替换为栈上分配提供了很好的基础。</p>
<p>由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>