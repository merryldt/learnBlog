<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://merryldt.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://merryldt.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>魔力社区</title>
    <link>https://merryldt.github.io/</link>
    <description>系统的梳理,可以让人思路清晰</description>
    <language>zh-CN</language>
    <pubDate>Tue, 22 Aug 2023 00:37:10 GMT</pubDate>
    <lastBuildDate>Tue, 22 Aug 2023 00:37:10 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>算法 二叉堆</category>
    <category>redis</category>
    <item>
      <title>Kubernetes 组件</title>
      <link>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/04_Kubernetes_Components.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes 组件</source>
      <description>Kubernetes 组件 前提 部署完 Kubernetes，便拥有了一个完整的集群。 一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。 工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。 image.png 控制平面组件（Control Plane Components） 控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes 组件</h1>
<h2> 前提</h2>
<p>部署完 Kubernetes，便拥有了一个完整的集群。</p>
<p>一组工作机器，称为节点， 会运行容器化应用程序。每个集群至少有一个工作节点。
工作节点会托管 Pod，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。
在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。</p>
<p>image.png</p>
<h2> 控制平面组件（Control Plane Components）</h2>
<p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件.(例如当不满足部署的 replicas 字段时， 要启动新的 pod）。控制平面组件可以在集群中的任何节点上运行。
然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p>
<h3> kube-apiserver</h3>
<p>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。
Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<h3> etcd</h3>
<p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。
如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 备份计划。</p>
<h3> kube-scheduler</h3>
<p>kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h3> kube-controller-manager</h3>
<p>kube-controller-manager 是控制平面的组件， 负责<strong>运行控制器进程</strong>。
从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。
例如:</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
<h3> cloud-controller-manager</h3>
<p>cloud-controller-manager 仅运行特定于云平台的控制器。
一个 Kubernetes 控制平面组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<h2> Node 组件</h2>
<p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h3> kubelet</h3>
<p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。
kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h3> kube-proxy</h3>
<p>kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。
kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。
如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<h3> Container Runtime</h3>
<p>容器运行环境是负责运行容器的软件。
Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。</p>
<h2> 插件(Addons)</h2>
<p>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p>
<h3> DNS</h3>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。
几乎所有 Kubernetes 集群都应该有集群 DNS。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Kubernetes API</title>
      <link>https://merryldt.github.io/moyu/k8s/05_Kubernetes_API.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/05_Kubernetes_API.html</guid>
      <source url="https://merryldt.github.io/rss.xml">Kubernetes API</source>
      <description>Kubernetes API Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。 Kubernetes API 使你可以在 Kubernetes 中查询和操纵 API 对象 （例如 Pod、Namespace、ConfigMap 和 Event）的状态。 操作工具 kubectl 命令行接口 kubeadm 持久化 Kubernetes 通过将序列化状态的对象写入到 etcd 中完成存储操作。</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Kubernetes API</h1>
<p>Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</p>
<p>Kubernetes API 使你可以在 Kubernetes 中查询和操纵 API 对象 （例如 Pod、Namespace、ConfigMap 和 Event）的状态。</p>
<h2> 操作工具</h2>
<ul>
<li>kubectl 命令行接口</li>
<li>kubeadm</li>
</ul>
<h2> 持久化</h2>
<p>Kubernetes 通过将序列化状态的对象写入到 etcd 中完成存储操作。</p>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://merryldt.github.io/moyu/k8s/06_Cluster_Architecture.html</link>
      <guid>https://merryldt.github.io/moyu/k8s/06_Cluster_Architecture.html</guid>
      <source url="https://merryldt.github.io/rss.xml"></source>
      <description>Nodes Communication between Nodes and the Control Plane</description>
      <pubDate>Tue, 22 Aug 2023 00:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Nodes</h2>
<h2> Communication between Nodes and the Control Plane</h2>
]]></content:encoded>
    </item>
    <item>
      <title>二叉堆</title>
      <link>https://merryldt.github.io/moyu/algorithm/datastructure/PriorityQueue.html</link>
      <guid>https://merryldt.github.io/moyu/algorithm/datastructure/PriorityQueue.html</guid>
      <source url="https://merryldt.github.io/rss.xml">二叉堆</source>
      <description>二叉堆 二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针： 两种类型: 最大堆和最小堆： 最大堆的性质是：每个节点都大于等于它的两个子节点; 最小堆的性质是：每个节点都小于等于它的子节点。 两个操作： swim(上浮) 和 sink(下沉) 在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。 最大堆的实现：</description>
      <category>算法 二叉堆</category>
      <pubDate>Fri, 04 Aug 2023 15:28:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 二叉堆</h2>
<p>二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>
<h2> 两种类型: 最大堆和最小堆：</h2>
<ul>
<li>最大堆的性质是：每个节点都大于等于它的两个子节点;</li>
<li>最小堆的性质是：每个节点都小于等于它的子节点。</li>
</ul>
<h2> 两个操作： swim(上浮) 和 sink(下沉)</h2>
<p>在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<h3> 最大堆的实现：</h3>
<p>对于最大堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<h3> 最小堆的实现：</h3>
<p>对于最小堆，会破坏堆性质的有两种情况：</p>
<p>1、如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</p>
<p>2、如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</p>
<h2> 基本操作代码</h2>
<h3> 节点操作</h3>

<h3> 上浮和下沉</h3>
]]></content:encoded>
    </item>
    <item>
      <title>01) Redis 概览</title>
      <link>https://merryldt.github.io/moyu/redis/01_redis.html</link>
      <guid>https://merryldt.github.io/moyu/redis/01_redis.html</guid>
      <source url="https://merryldt.github.io/rss.xml">01) Redis 概览</source>
      <category>redis</category>
      <pubDate>Sat, 29 Jul 2023 15:23:28 GMT</pubDate>
    </item>
  </channel>
</rss>