---
title: Jvm的内存结构和对象分配
subtitle: Jvm的内存结构和对象分配
category:
  - JVM
tag:
  - 摸鱼
order: 2
---

# 图示
![Alt text](./image/02-1.png)

# JVM 内存区域

内存是非常重要的系统资源，是硬盘和CPU 的中间仓库及桥梁，承载着操作系统和应用的实时运行。
JVM 内存布局规定了Java 在运行过程中内存申请、分配、管理的策略， 保证了JVM 的高效稳定运行。
不同的JVM 对于内存的划分方式和管理机制存在着部分差异。结合JVM 虚拟机规范，来探讨一下经典的JVM
内存布局。

## 线程
每个JVM 只有一个Runtime 实例。即为运行时环境。

线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。

在Hopsopt JVM 中，每个线程都与操作系统的本地线程直接映射。
   >当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后,本地线程也会回收。

操作系统负责所有线程的安排调度到任何一个可用的CPU 上。一旦本地线程初始化成功个，它就会调用Java 线程中的run()方法。
### 守护线程、普通线程
 

## 一、程序计算器

极小的内存空间,线程私有的,当前线程的行号指示器，程序的分支、循环、跳转、异常处理、线程恢复等基本功能都需要依赖程序计算器；比如(多线程切换)。

线程执行的是:</br>
1. Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</br>
2. Native方法，计数器值为空；值得注意的是它是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域

## 二、java虚拟机栈

1. 虚拟机栈描述的是java方法执行的内存模型：线程私有的，生命周期与线程相同。</br>

2. 每个方法在执行的同时都会创建一个栈帧用于 存储局部变量表、操作数栈、动态链接、方法出口等信息；方法的调用直至执行完成的过程，对应着栈帧在虚拟机栈中入栈到出栈的过程。

3. 虚拟机栈主要的部分是**局部变量表** ，其存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址);

4. 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。

5. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出OutOfMemoryErro异常。

## 三、本地方法栈

与虚拟机栈作用类似，本地方法栈是虚拟机栈使用到的Native方法服务；SunHotSpot虚拟机把本地方法栈和虚拟机栈结合; 本地方法栈也会报虚拟机栈的两种异常。

## 四、java堆

1. java虚拟机管理的最大的一块内存；

2. 所有线程共享的内存区域；

3. 目的：存放对象实例，几乎所有的对象实例都在这里分配内存；（所有的对象实例以及数组都要在堆上分配）特别注意的是： 随着JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术带来了变化。不是所有对象都在堆上分配内存了。

4. java虚拟机规范规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可；实现时，即可是固定大小的，也可是可扩展的；当前主流的虚拟机都是可扩展的，通过-Xmx和-Xms控制； 如果堆中没有内存，并且堆也无法扩展 ，抛出OutOfMemoryError异常。

5. java堆是垃圾收集的主要区域，也称为“GC堆”;

   . 从内存回收的角度：基本采用分代收集算法，java堆分为新生代(Eden空间、From Survivor空间、To Survivor空间)和老年代；
   . 从内存分配的角度：线程共享的java堆中可能划分出多个线程私有的分配缓冲区。目的是为了更好地、更快地回收内存。

## 五、方法区

1. 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
2. 所有线程共享的内存区域。
3. 在HostSpot虚拟机中，使用永久代来实现方法区，这样的话垃圾收集器可以像管理Java堆一样管理这部分内存； Jdk1.7中，永久代中的字符串常量池移出。 为Native Memory实现方法区做准备。
4. 方法区和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集；垃圾收集行为在方法区较少出现，方法区的内存回收目标主要是针对常量池的回收和对类型的卸载；（回收效果差，类型卸载要求高）回收非常有必要，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 六、运行时常量池

1. 方法区的一部分;
2. 存放的是类加载后class文件中常量池的信息;Class文件包括： 1 常量池(用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中) 2 类的基本描述信息（字段、方法、接口）

运行时常量池，细节要求不高，可以根据不同的需求来实现该内存区域； Class包括其中的常量池，格式要求严格，具体到每一个字节存储的数据都必须符合才能被虚拟机认可、装载和执行；运行时常量池，不仅保存Class文件中描述的符号引用，而且也保存翻译的直接引用。

java语言的动态性，意味着并不要求常量一定只有编译器才能产生，也就是说不是只有提前放置在Class文件常量池中的内容才能进入方法区的运行时常量池； 在运行期也可以将新的常量放入运行时常量池，比如String的intern（）方法(调用该方法，如果常量池中包含了一个和当前对象相等的字符串则返回常量池中的字符串， 否则把改字符串放到常量池中，并返回字符串的引用.)；常量池可能报OutOfMemoryError异常。

常量池在运行时加载到内存中后,称为运行时常量池。
## 七、直接内存

1. NIO类，一种基于通道与缓存区的I/o方式，可以使用Native函数库直接分配堆外内存，通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用；
2. NIO的使用在某些场合避免了在java堆和Native堆中来回复制数据，提高了性能；
3. 直接内存不受java堆大小的控制，但是受到本机总内存大小以及处理器寻址空间的限制；
4. 也是会报OutOfMemoryError异常。

# 知识补充：
## 逃逸分析
目的就是减少内存堆分配压力；

逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它有可能被外部方法所引用，例如，作为调用参数传递到其他地方中，称为方法逃逸。
### 基于逃逸分析，可以进行 同步消除、栈上分配以及标量替换的优化。
### 例子：
```
    public static StringBuffer craeteStringBuffer(String s1, String s2) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb;
    }
```
StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部
。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

上述代码如果想要StringBuffer sb不逃出方法，可以做一些修改：

```
    public static StringBuffer craeteStringBuffer(String s1, String s2) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        String result = sb.toString();
        return result;
    }
```

逃逸分析包括：

+ 全局变量赋值逃逸
+ 方法返回值逃逸
+ 实例引用发生逃逸
+ 线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量

```
public class EscapeAnalysis {
 
     public static Object object;
     
     public void globalVariableEscape(){   //全局变量赋值逃逸  
         object =new Object();  
      }  
     
     public Object methodEscape(){    //方法返回值逃逸
         return new Object();
     }
     
     public void instancePassEscape(){   //实例引用发生逃逸
        this.speak(this);
     }
     
     public void speak(EscapeAnalysis escapeAnalysis){
         System.out.println("Escape Hello");
     }
}
```

## 同步消除(锁消除)
如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。

如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。

虚拟机会根据自己的代码检测结果取消一些加锁逻辑。

虚拟机通过检测会发现一些代码中不可能出现数据竞争，但是代码中又有加锁逻辑，为了提高性能，就消除这些锁。

如果一段代码中，在堆上的所有数据都不会被其他线程访问到，那就可以把它们当成线程私有数据，自然就不需要同步加锁了。

### 经典例子：
String 字符串拼接：
```
    String a = "hello";
    String b = "world";
    String c = a+b;
```
打开编译后的字节码我们可以发现加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b”等效于下面的代码片。
```
    String a = "a";
    StringBuilder sb = new StringBuilder();
    sb.append(a).append("b");
    String c = sb.toString();
```
append方法时一个同步方法，它的方法签名是：
```
    public synchronized StringBuffer append(String str);
```
这时候，编译器就会判断出sb这个对象并不会被这段代码块以外的地方访问到，更不会被其他线程访问到，这时候的加锁就是完全没必要的，编译器就会把这里的加锁代码消除掉，
体现到java源码上就是把append方法的synchronized修饰符给去掉了。


## 栈上分配
1. 虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。
2. 栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。
3. 如果逃逸分析能够证明某些新建的 **对象不逃逸** ，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。

## 标量替换
定义：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。

```
    public static void main(String[] args) {
       alloc();
    }
     
    private static void alloc() {
       Point point = new Point（1,2）;
       System.out.println("point.x="+point.x+"; point.y="+point.y);
    }
    class Point{
        private int x;
        private int y;
    }
```
以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。

以上代码，经过标量替换后，就会变成：

```
    private static void alloc() {
       int x = 1;
       int y = 2;
       System.out.println("point.x="+x+"; point.y="+y);
    }
```
减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

标量替换为栈上分配提供了很好的基础。

由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。


