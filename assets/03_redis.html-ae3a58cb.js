const n=JSON.parse('{"key":"v-7893a9e4","path":"/moyu/redis/03_redis.html","title":"缓存击穿、穿透、雪崩","lang":"zh-CN","frontmatter":{"title":"缓存击穿、穿透、雪崩","subtitle":"缓存击穿、缓存穿透、缓存雪崩","category":["redis"],"tag":["摸鱼 需要整理成自己的话"],"order":3,"description":"1 一、缓存击穿（热点失效） 原因: 缓存不存在 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 过期时间再加⼀个随机值。设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }","head":[["meta",{"property":"og:url","content":"https://merryldt.github.io/moyu/redis/03_redis.html"}],["meta",{"property":"og:site_name","content":"魔力社区"}],["meta",{"property":"og:title","content":"缓存击穿、穿透、雪崩"}],["meta",{"property":"og:description","content":"1 一、缓存击穿（热点失效） 原因: 缓存不存在 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 过期时间再加⼀个随机值。设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-28T09:00:54.000Z"}],["meta",{"property":"article:author","content":"坎布里奇"}],["meta",{"property":"article:tag","content":"摸鱼 需要整理成自己的话"}],["meta",{"property":"article:modified_time","content":"2023-07-28T09:00:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存击穿、穿透、雪崩\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-28T09:00:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"坎布里奇\\",\\"url\\":\\"https://merryldt.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"一、缓存击穿（热点失效）","slug":"一、缓存击穿-热点失效","link":"#一、缓存击穿-热点失效","children":[{"level":3,"title":"原因: 缓存不存在","slug":"原因-缓存不存在","link":"#原因-缓存不存在","children":[]},{"level":3,"title":"解决方案：","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":2,"title":"二、缓存穿透(不存在)","slug":"二、缓存穿透-不存在","link":"#二、缓存穿透-不存在","children":[{"level":3,"title":"原因：数据在【缓存和数据库】中不存在","slug":"原因-数据在【缓存和数据库】中不存在","link":"#原因-数据在【缓存和数据库】中不存在","children":[]},{"level":3,"title":"解决⽅案","slug":"解决方案-1","link":"#解决方案-1","children":[]}]},{"level":2,"title":"三、缓存雪崩（大面积失效）","slug":"三、缓存雪崩-大面积失效","link":"#三、缓存雪崩-大面积失效","children":[{"level":3,"title":"原因一：缓存⼤量数据同时过期","slug":"原因一-缓存大量数据同时过期","link":"#原因一-缓存大量数据同时过期","children":[]},{"level":3,"title":"原因一：解决⽅案","slug":"原因一-解决方案","link":"#原因一-解决方案","children":[]},{"level":3,"title":"原因二：Redis 故障宕机","slug":"原因二-redis-故障宕机","link":"#原因二-redis-故障宕机","children":[]},{"level":3,"title":"原因二： 解决方案：","slug":"原因二-解决方案","link":"#原因二-解决方案","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考","slug":"思考","link":"#思考","children":[]}],"git":{"createdTime":1690479817000,"updatedTime":1690534854000,"contributors":[{"name":"kansuper","email":"17835059864@163.com","commits":4}]},"readingTime":{"minutes":5.95,"words":1785},"filePathRelative":"moyu/redis/03_redis.md","localizedDate":"2023年7月27日","excerpt":"<h1> 1</h1>\\n<h2> 一、缓存击穿（热点失效）</h2>\\n<h3> 原因: 缓存不存在</h3>\\n<ul>\\n<li>背景: 缓存被删除或者失效</li>\\n<li>现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。</li>\\n<li>关键字：单⼀热点数据、⾼并发、数据失效</li>\\n<li>描述：\\n⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。</li>\\n</ul>\\n<h3> 解决方案：</h3>\\n<ol>\\n<li>\\n<p>过期时间 + 随机值</p>\\n<p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。<br>\\n过期时间再加⼀个随机值。设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒</p>\\n</li>\\n<li>\\n<p>预热<br>\\n分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。</p>\\n</li>\\n<li>\\n<p>加锁</p>\\n<ul>\\n<li>当发现缓存失效的时候，不是⽴即从数据库加载数据。</li>\\n<li>⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。</li>\\n<li>这样只让⼀个请求去数据库读取数据</li>\\n</ul>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code> <span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">Object</span> <span class=\\"token function\\">getData</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span> id<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n     <span class=\\"token class-name\\">String</span> desc <span class=\\"token operator\\">=</span> redis<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">get</span><span class=\\"token punctuation\\">(</span>id<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n     <span class=\\"token comment\\">// 缓存为空，过期了</span>\\n     <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>desc <span class=\\"token operator\\">==</span> <span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n         <span class=\\"token comment\\">// 互斥锁，只有⼀个请求可以成功</span>\\n         <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span><span class=\\"token function\\">redis</span><span class=\\"token punctuation\\">(</span>lockName<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n             <span class=\\"token keyword\\">try</span><span class=\\"token punctuation\\">{</span>\\n                 <span class=\\"token comment\\">// 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。</span>\\n                desc <span class=\\"token operator\\">=</span> redis<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">get</span><span class=\\"token punctuation\\">(</span>id<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">null</span> <span class=\\"token operator\\">!=</span> desc<span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">return</span> desc<span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token comment\\">// 从数据库取出数据</span>\\n                desc <span class=\\"token operator\\">=</span> <span class=\\"token function\\">getFromDB</span><span class=\\"token punctuation\\">(</span>id<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token comment\\">// 写到 Redis</span>\\n                redis<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">set</span><span class=\\"token punctuation\\">(</span>id<span class=\\"token punctuation\\">,</span> desc<span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">60</span> <span class=\\"token operator\\">*</span> <span class=\\"token number\\">60</span> <span class=\\"token operator\\">*</span> <span class=\\"token number\\">24</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n             <span class=\\"token punctuation\\">}</span> <span class=\\"token keyword\\">catch</span> <span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">Exception</span> ex<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n                 <span class=\\"token class-name\\">LogHelper</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">error</span><span class=\\"token punctuation\\">(</span>ex<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n             <span class=\\"token punctuation\\">}</span> <span class=\\"token keyword\\">finally</span> <span class=\\"token punctuation\\">{</span>\\n                <span class=\\"token comment\\">// 确保最后删除，释放锁</span>\\n                redis<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">del</span><span class=\\"token punctuation\\">(</span>lockName<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token keyword\\">return</span> desc<span class=\\"token punctuation\\">;</span>\\n             <span class=\\"token punctuation\\">}</span>\\n        <span class=\\"token punctuation\\">}</span> <span class=\\"token keyword\\">else</span> <span class=\\"token punctuation\\">{</span>\\n            <span class=\\"token comment\\">// 否则睡眠200ms，接着获取锁</span>\\n            <span class=\\"token class-name\\">Thread</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">sleep</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">200</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token keyword\\">return</span> <span class=\\"token function\\">getData</span><span class=\\"token punctuation\\">(</span>id<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token punctuation\\">}</span>\\n     <span class=\\"token punctuation\\">}</span>\\n <span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ol>","autoDesc":true}');export{n as data};
