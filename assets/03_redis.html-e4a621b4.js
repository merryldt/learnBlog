const e=JSON.parse('{"key":"v-7893a9e4","path":"/moyu/redis/03_redis.html","title":"缓存击穿、穿透、雪崩","lang":"zh-CN","frontmatter":{"title":"缓存击穿、穿透、雪崩","subtitle":"缓存击穿、缓存穿透、缓存雪崩","category":["redis"],"tag":["摸鱼 需要整理成自己的话"],"order":3,"description":"缓存击穿（失效） 原因: 缓存不存在 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 或者过期时间再加⼀个随机值。 设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }","head":[["meta",{"property":"og:url","content":"https://merryldt.github.io/moyu/redis/03_redis.html"}],["meta",{"property":"og:site_name","content":"魔力社区"}],["meta",{"property":"og:title","content":"缓存击穿、穿透、雪崩"}],["meta",{"property":"og:description","content":"缓存击穿（失效） 原因: 缓存不存在 背景: 缓存被删除或者失效 现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。 关键字：单⼀热点数据、⾼并发、数据失效 描述： ⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。 解决方案： 过期时间 + 随机值 对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。 或者过期时间再加⼀个随机值。 设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒ 预热 分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。 加锁 当发现缓存失效的时候，不是⽴即从数据库加载数据。 ⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。 这样只让⼀个请求去数据库读取数据 public Object getData(String id) { String desc = redis.get(id); // 缓存为空，过期了 if (desc == null) { // 互斥锁，只有⼀个请求可以成功 if (redis(lockName)) { try{ // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。 desc = redis.get(id); if(null != desc) return desc; // 从数据库取出数据 desc = getFromDB(id); // 写到 Redis redis.set(id, desc, 60 * 60 * 24); } catch (Exception ex) { LogHelper.error(ex); } finally { // 确保最后删除，释放锁 redis.del(lockName); return desc; } } else { // 否则睡眠200ms，接着获取锁 Thread.sleep(200); return getData(id); } } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-27T17:52:49.000Z"}],["meta",{"property":"article:author","content":"坎布里奇"}],["meta",{"property":"article:tag","content":"摸鱼 需要整理成自己的话"}],["meta",{"property":"article:modified_time","content":"2023-07-27T17:52:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存击穿、穿透、雪崩\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-27T17:52:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"坎布里奇\\",\\"url\\":\\"https://merryldt.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"缓存击穿（失效）","slug":"缓存击穿-失效","link":"#缓存击穿-失效","children":[{"level":3,"title":"原因: 缓存不存在","slug":"原因-缓存不存在","link":"#原因-缓存不存在","children":[]},{"level":3,"title":"解决方案：","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":2,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[{"level":3,"title":"原因：数据在【缓存和数据库】中不存在","slug":"原因-数据在【缓存和数据库】中不存在","link":"#原因-数据在【缓存和数据库】中不存在","children":[]},{"level":3,"title":"解决⽅案","slug":"解决方案-1","link":"#解决方案-1","children":[]}]},{"level":2,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[{"level":3,"title":"原因一：缓存⼤量数据同时过期","slug":"原因一-缓存大量数据同时过期","link":"#原因一-缓存大量数据同时过期","children":[]},{"level":3,"title":"原因一：解决⽅案","slug":"原因一-解决方案","link":"#原因一-解决方案","children":[]},{"level":3,"title":"原因二：Redis 故障宕机","slug":"原因二-redis-故障宕机","link":"#原因二-redis-故障宕机","children":[]},{"level":3,"title":"原因二： 解决方案：","slug":"原因二-解决方案","link":"#原因二-解决方案","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考","slug":"思考","link":"#思考","children":[]}],"git":{"createdTime":1690479817000,"updatedTime":1690480369000,"contributors":[{"name":"kansuper","email":"17835059864@163.com","commits":2}]},"readingTime":{"minutes":6.78,"words":2034},"filePathRelative":"moyu/redis/03_redis.md","localizedDate":"2023年7月27日","excerpt":"<h2> 缓存击穿（失效）</h2>\\n<h3> 原因: 缓存不存在</h3>\\n<ul>\\n<li>背景: 缓存被删除或者失效</li>\\n<li>现象：热点数据，直接请求数据库，由于⾼并发，可能会把 DB 压垮，导致服务不可⽤。</li>\\n<li>关键字：单⼀热点数据、⾼并发、数据失效</li>\\n<li>描述：\\n⾼并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那⼀份已经过期，后端需要从 DB 从加载数据并写到 Redis。</li>\\n</ul>\\n<h3> 解决方案：</h3>\\n<ol>\\n<li>\\n<p>过期时间 + 随机值</p>\\n<p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis ⾼吞吐量性能利⽤起来。\\n或者过期时间再加⼀个随机值。<br>\\n设计缓存的过期时间时，使⽤公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加⼀个随机的过期时间，让数据在未来⼀段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过⼤压⼒</p>\\n</li>\\n<li>\\n<p>预热<br>\\n分析热门数据,单独处理。预先把热⻔数据提前存⼊ Redis 中，并设热⻔数据的过期时间超⼤值。</p>\\n</li>\\n<li>\\n<p>加锁</p>\\n<ul>\\n<li>当发现缓存失效的时候，不是⽴即从数据库加载数据。</li>\\n<li>⽽是先获取分布式锁，获取锁成功，再去查询一次缓存，如果为null,才执⾏数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执数据库查询操作，当前线程睡眠⼀段时间在重试。</li>\\n<li>这样只让⼀个请求去数据库读取数据</li>\\n</ul>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code> public Object getData(String id) {\\n     String desc = redis.get(id);\\n     // 缓存为空，过期了\\n     if (desc == null) {\\n         // 互斥锁，只有⼀个请求可以成功\\n         if (redis(lockName)) {\\n             try{\\n                 // 这里一定要再读一次，不然大量请求到了这一步，就算缓存中有了，也要全部请求一次数据库。\\n                desc = redis.get(id);\\n                if(null != desc) return desc;\\n                // 从数据库取出数据\\n                desc = getFromDB(id);\\n                // 写到 Redis\\n                redis.set(id, desc, 60 * 60 * 24);\\n             } catch (Exception ex) {\\n                 LogHelper.error(ex);\\n             } finally {\\n                // 确保最后删除，释放锁\\n                redis.del(lockName);\\n                return desc;\\n             }\\n        } else {\\n            // 否则睡眠200ms，接着获取锁\\n            Thread.sleep(200);\\n            return getData(id);\\n        }\\n     }\\n }\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ol>","autoDesc":true}');export{e as data};
