import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,b as l}from"./app-ca946318.js";const r={},t=l('<h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><p>你遇到数据量⼤，⼜需要去重的时候就可以考虑布隆过滤器</p><ul><li>解决 Redis 缓存穿透问题（⾯试重点）；</li><li>邮件过滤，使⽤布隆过滤器实现邮件⿊名单过滤；</li><li>触发过的事件,不触发；</li></ul><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ul><li>布隆过滤器 (Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出，它是⼀种 space efficient 的概率型数据结构，⽤于判断⼀个元素是否在集合中。</li><li>当布隆过滤器说，某个数据存在时，这个数据可能不存在；当布隆过滤器说，某个数据不存在时，那么这个数据⼀定不存在。</li><li>哈希表也能⽤于判断元素是否在集合中，但是布隆过滤器只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。</li><li>布隆过滤器可以插⼊元素，但不可以删除已有元素。</li><li>其中的元素越多，false positive rate(误报率)越⼤，但是 false negative (漏报)是不可能的。</li></ul><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><p>BloomFilter 的算法</p><ol><li>首先分配一块内存空间做bit 数组，数组的bit位初始值全部设为0.</li><li>加入元素时，采用k个相互独立的Hash 函数计算，然后将元素Hash 映射的K个位置全部设置为1.</li><li>检测key是否存在，仍然用这k个Hash函数计算出k个位置，如果位置全部为1，则表明key存在，否则不存在。</li></ol><h3 id="误判率是为甚么" tabindex="-1"><a class="header-anchor" href="#误判率是为甚么" aria-hidden="true">#</a> 误判率是为甚么？</h3><p><strong>哈希函数会出现碰撞，所以布隆过滤器会存在误判</strong></p><ul><li>误判率是指： BloomFilter判断某个key存在，但它实际不存在的概率，因为它存的是key的Hash值，而非key的值。</li><li>所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同</li></ul><p><em>对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，⽽不会是 0。布隆过滤器判断存在不⼀定真的存在。</em></p><h3 id="为什么不允许删除元素呢" tabindex="-1"><a class="header-anchor" href="#为什么不允许删除元素呢" aria-hidden="true">#</a> 为什么不允许删除元素呢？</h3><ul><li>删除意味着需要将对应的 k 个 bits 位置设置为 0，其中有可能是其他元素对应的位。</li><li>因此 remove 会引⼊ false negative，这是绝对不被允许的</li></ul>',14),h=[t];function s(o,d){return i(),a("div",null,h)}const u=e(r,[["render",s],["__file","06_redis.html.vue"]]);export{u as default};
