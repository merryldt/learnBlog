const t=JSON.parse('{"key":"v-44dc560a","path":"/moyu/algorithm/datastructure/PriorityQueue.html","title":"二叉堆","lang":"zh-CN","frontmatter":{"title":"二叉堆","subtitle":"二叉堆","category":["算法 二叉堆"],"tag":["摸鱼"],"order":1,"description":"二叉堆 二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针： 两种类型: 最大堆和最小堆： 最大堆的性质是：每个节点都大于等于它的两个子节点; 最小堆的性质是：每个节点都小于等于它的子节点。 两个操作： swim(上浮) 和 sink(下沉) 在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。 最大堆的实现：","head":[["meta",{"property":"og:url","content":"https://merryldt.github.io/moyu/algorithm/datastructure/PriorityQueue.html"}],["meta",{"property":"og:site_name","content":"魔力社区"}],["meta",{"property":"og:title","content":"二叉堆"}],["meta",{"property":"og:description","content":"二叉堆 二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针： 两种类型: 最大堆和最小堆： 最大堆的性质是：每个节点都大于等于它的两个子节点; 最小堆的性质是：每个节点都小于等于它的子节点。 两个操作： swim(上浮) 和 sink(下沉) 在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。 最大堆的实现："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-04T15:28:34.000Z"}],["meta",{"property":"article:author","content":"坎布里奇"}],["meta",{"property":"article:tag","content":"摸鱼"}],["meta",{"property":"article:modified_time","content":"2023-08-04T15:28:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉堆\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-04T15:28:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"坎布里奇\\",\\"url\\":\\"https://merryldt.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"二叉堆","slug":"二叉堆","link":"#二叉堆","children":[]},{"level":2,"title":"两种类型: 最大堆和最小堆：","slug":"两种类型-最大堆和最小堆","link":"#两种类型-最大堆和最小堆","children":[]},{"level":2,"title":"两个操作： swim(上浮) 和 sink(下沉)","slug":"两个操作-swim-上浮-和-sink-下沉","link":"#两个操作-swim-上浮-和-sink-下沉","children":[{"level":3,"title":"最大堆的实现：","slug":"最大堆的实现","link":"#最大堆的实现","children":[]},{"level":3,"title":"最小堆的实现：","slug":"最小堆的实现","link":"#最小堆的实现","children":[]}]},{"level":2,"title":"基本操作代码","slug":"基本操作代码","link":"#基本操作代码","children":[{"level":3,"title":"节点操作","slug":"节点操作","link":"#节点操作","children":[]},{"level":3,"title":"上浮和下沉","slug":"上浮和下沉","link":"#上浮和下沉","children":[]}]}],"git":{"createdTime":1691162914000,"updatedTime":1691162914000,"contributors":[{"name":"kansuper","email":"17835059864@163.com","commits":1}]},"readingTime":{"minutes":1.81,"words":542},"filePathRelative":"moyu/algorithm/datastructure/PriorityQueue.md","localizedDate":"2023年8月4日","excerpt":"<h2> 二叉堆</h2>\\n<p>二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>\\n<h2> 两种类型: 最大堆和最小堆：</h2>\\n<ul>\\n<li>最大堆的性质是：每个节点都大于等于它的两个子节点;</li>\\n<li>最小堆的性质是：每个节点都小于等于它的子节点。</li>\\n</ul>\\n<h2> 两个操作： swim(上浮) 和 sink(下沉)</h2>\\n<p>在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>\\n<h3> 最大堆的实现：</h3>","autoDesc":true}');export{t as data};
