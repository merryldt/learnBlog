const e=JSON.parse('{"key":"v-58eaa4a3","path":"/moyu/jvm/02_Jvm_Memory1ClassReload.html","title":"类的加载","lang":"zh-CN","frontmatter":{"title":"类的加载","subtitle":"类的加载","category":["JVM"],"tag":["摸鱼"],"order":2.1,"description":"类的生命周期 一、过程 加载（load） 通过一个类的全限定名来获取定义此类的二进制字节流; 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构; 链接(Linking) 校验 目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。","head":[["meta",{"property":"og:url","content":"https://merryldt.github.io/moyu/jvm/02_Jvm_Memory1ClassReload.html"}],["meta",{"property":"og:site_name","content":"魔力社区"}],["meta",{"property":"og:title","content":"类的加载"}],["meta",{"property":"og:description","content":"类的生命周期 一、过程 加载（load） 通过一个类的全限定名来获取定义此类的二进制字节流; 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构; 链接(Linking) 校验 目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://merryldt.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-22T11:47:07.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"类的加载"}],["meta",{"property":"article:author","content":"坎布里奇"}],["meta",{"property":"article:tag","content":"摸鱼"}],["meta",{"property":"article:modified_time","content":"2023-07-22T11:47:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类的加载\\",\\"image\\":[\\"https://merryldt.github.io/\\"],\\"dateModified\\":\\"2023-07-22T11:47:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"坎布里奇\\",\\"url\\":\\"https://merryldt.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"加载（load）","slug":"加载-load","link":"#加载-load","children":[]},{"level":2,"title":"链接(Linking)","slug":"链接-linking","link":"#链接-linking","children":[{"level":3,"title":"校验","slug":"校验","link":"#校验","children":[]},{"level":3,"title":"准备","slug":"准备","link":"#准备","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[]}]},{"level":2,"title":"初始化","slug":"初始化","link":"#初始化","children":[{"level":3,"title":"初始化时机：","slug":"初始化时机","link":"#初始化时机","children":[]}]},{"level":2,"title":"例子：","slug":"例子","link":"#例子","children":[]},{"level":2,"title":"类加载器从两个角度区分:","slug":"类加载器从两个角度区分","link":"#类加载器从两个角度区分","children":[]},{"level":2,"title":"类加载器的作用","slug":"类加载器的作用","link":"#类加载器的作用","children":[]},{"level":2,"title":"介绍三种类加载器","slug":"介绍三种类加载器","link":"#介绍三种类加载器","children":[{"level":3,"title":"启动类加载器(Bootstrap ClassLoader)","slug":"启动类加载器-bootstrap-classloader","link":"#启动类加载器-bootstrap-classloader","children":[]},{"level":3,"title":"扩展类加载器(Extension ClassLoader)","slug":"扩展类加载器-extension-classloader","link":"#扩展类加载器-extension-classloader","children":[]},{"level":3,"title":"应用程序类加载器(Application ClassLoader)","slug":"应用程序类加载器-application-classloader","link":"#应用程序类加载器-application-classloader","children":[]}]},{"level":2,"title":"自定义类加载器","slug":"自定义类加载器","link":"#自定义类加载器","children":[{"level":3,"title":"为什么要自定义类加载器","slug":"为什么要自定义类加载器","link":"#为什么要自定义类加载器","children":[]}]},{"level":2,"title":"类加载器之间的关系","slug":"类加载器之间的关系","link":"#类加载器之间的关系","children":[{"level":3,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[]}]},{"level":2,"title":"局限性","slug":"局限性","link":"#局限性","children":[{"level":3,"title":"破坏双亲委派模型","slug":"破坏双亲委派模型","link":"#破坏双亲委派模型","children":[]},{"level":3,"title":"一、无法解决基础类回调用户的代；","slug":"一、无法解决基础类回调用户的代","link":"#一、无法解决基础类回调用户的代","children":[]},{"level":3,"title":"二、用户对程序动态性的追求。","slug":"二、用户对程序动态性的追求。","link":"#二、用户对程序动态性的追求。","children":[]},{"level":3,"title":"三、自定义类加载器的原则：","slug":"三、自定义类加载器的原则","link":"#三、自定义类加载器的原则","children":[]}]},{"level":2,"title":"知识补充","slug":"知识补充","link":"#知识补充","children":[{"level":3,"title":"沙箱安全机制","slug":"沙箱安全机制","link":"#沙箱安全机制","children":[]},{"level":3,"title":"比较两个Class 对象是否为同一个类:","slug":"比较两个class-对象是否为同一个类","link":"#比较两个class-对象是否为同一个类","children":[]},{"level":3,"title":"类的主动使用和被动使用","slug":"类的主动使用和被动使用","link":"#类的主动使用和被动使用","children":[]}]}],"git":{"createdTime":1689742097000,"updatedTime":1690026427000,"contributors":[{"name":"kansuper","email":"17835059864@163.com","commits":24}]},"readingTime":{"minutes":12.36,"words":3708},"filePathRelative":"moyu/jvm/02_Jvm_Memory1ClassReload.md","localizedDate":"2023年7月19日","excerpt":"<figure><figcaption>类的生命周期</figcaption></figure>\\n<h1> 一、过程</h1>\\n<h2> 加载（load）</h2>\\n<ol>\\n<li>通过一个类的全限定名来获取定义此类的二进制字节流;</li>\\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;</li>\\n</ol>\\n<h2> 链接(Linking)</h2>\\n<h3> 校验</h3>\\n<p>目的是在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>\\n主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>","autoDesc":true}');export{e as data};
