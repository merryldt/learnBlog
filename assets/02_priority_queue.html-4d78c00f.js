const e=JSON.parse('{"key":"v-cd8475c2","path":"/moyu/algorithm/basic/02_priority_queue.html","title":"优先队列","lang":"zh-CN","frontmatter":{"description":"优先队列 实现核心： 二叉堆 定义： 二叉堆（Binary Heap）性质比二叉搜索树 BST 还简单。其主要操作就两个，sin（下沉）和&nbsp;swim（上浮），用以维护二叉堆的性质。 二叉堆在逻辑上是一种特殊的二叉树（完全二叉树），只不过存储在数组里。 图示： arr是一个字符数组，注意数组的第一个索引 0 空着不用。 把&nbsp;arr[1]作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。","head":[["meta",{"property":"og:url","content":"https://merryldt.github.io/moyu/algorithm/basic/02_priority_queue.html"}],["meta",{"property":"og:site_name","content":"魔力社区"}],["meta",{"property":"og:title","content":"优先队列"}],["meta",{"property":"og:description","content":"优先队列 实现核心： 二叉堆 定义： 二叉堆（Binary Heap）性质比二叉搜索树 BST 还简单。其主要操作就两个，sin（下沉）和&nbsp;swim（上浮），用以维护二叉堆的性质。 二叉堆在逻辑上是一种特殊的二叉树（完全二叉树），只不过存储在数组里。 图示： arr是一个字符数组，注意数组的第一个索引 0 空着不用。 把&nbsp;arr[1]作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-13T08:51:31.000Z"}],["meta",{"property":"article:author","content":"坎布里奇"}],["meta",{"property":"article:modified_time","content":"2025-01-13T08:51:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"优先队列\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-13T08:51:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"坎布里奇\\",\\"url\\":\\"https://merryldt.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"实现核心： 二叉堆","slug":"实现核心-二叉堆","link":"#实现核心-二叉堆","children":[{"level":3,"title":"定义：","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"数组的方式，操作树的索引：","slug":"数组的方式-操作树的索引","link":"#数组的方式-操作树的索引","children":[]},{"level":3,"title":"最大堆和最小堆：","slug":"最大堆和最小堆","link":"#最大堆和最小堆","children":[]}]},{"level":2,"title":"实现 swim 和 sink","slug":"实现-swim-和-sink","link":"#实现-swim-和-sink","children":[{"level":3,"title":"最大堆的实现：","slug":"最大堆的实现","link":"#最大堆的实现","children":[]},{"level":3,"title":"最小堆的实现：","slug":"最小堆的实现","link":"#最小堆的实现","children":[]}]},{"level":2,"title":"插入和删除操作：","slug":"插入和删除操作","link":"#插入和删除操作","children":[]},{"level":2,"title":"最大堆的完整实现：","slug":"最大堆的完整实现","link":"#最大堆的完整实现","children":[]},{"level":2,"title":"最小堆的完整实现：","slug":"最小堆的完整实现","link":"#最小堆的完整实现","children":[]}],"git":{"createdTime":1736758291000,"updatedTime":1736758291000,"contributors":[{"name":"merry","email":"17835059864@163.com","commits":1}]},"readingTime":{"minutes":6.72,"words":2016},"filePathRelative":"moyu/algorithm/basic/02_priority_queue.md","localizedDate":"2025年1月13日","excerpt":"<h1> 优先队列</h1>\\n<h2> 实现核心： 二叉堆</h2>\\n<h3> 定义：</h3>\\n<p>二叉堆（Binary Heap）性质比二叉搜索树 BST 还简单。其主要操作就两个，<code>sin</code>（下沉）和&nbsp;<code>swim</code>（上浮），用以维护二叉堆的性质。</p>\\n<p>二叉堆在逻辑上是一种特殊的二叉树（完全二叉树），只不过存储在数组里。</p>\\n<p>图示：</p>\\n<p><code>arr</code>是一个字符数组，注意数组的第一个索引 0 空着不用。</p>\\n<p>把&nbsp;<code>arr[1]</code>作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p>","autoDesc":true}');export{e as data};
